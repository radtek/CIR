//////////////////////////////////////////////////////////////////////
// LLBLGen Pro is (c) 2002-2007 Solutions Design. All rights reserved.
// http://www.llblgen.com
// The sourcecode for the ORM Support classes is released as BSD2 licensed 
// open source, so licensees of LLBLGen Pro can modify, update and/or extend it. 
// Distribution of this sourcecode and binary compiled versions of this sourcecode
// are licensed to LLBLGen Pro licensees using the following license below.
//////////////////////////////////////////////////////////////////////
// COPYRIGHTS:
// Copyright (c)2002-2006 Solutions Design. All rights reserved.
// 
// The ORM Support classes library sourcecode is released under the following license: (BSD2)
// ----------------------------------------------------------------------
// Redistribution and use in source and binary forms, with or without modification, 
// are permitted provided that the following conditions are met: 
//
// 1) Redistributions of source code must retain the above copyright notice, this list of 
//    conditions and the following disclaimer. 
// 2) Redistributions in binary form must reproduce the above copyright notice, this list of 
//    conditions and the following disclaimer in the documentation and/or other materials 
//    provided with the distribution. 
// 
// THIS SOFTWARE IS PROVIDED BY SOLUTIONS DESIGN ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, 
// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SOLUTIONS DESIGN OR CONTRIBUTORS BE LIABLE FOR 
// ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR 
// BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, 
// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE 
// USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
//
// The views and conclusions contained in the software and documentation are those of the authors 
// and should not be interpreted as representing official policies, either expressed or implied, 
// of Solutions Design. 
//
//////////////////////////////////////////////////////////////////////
// Contributers to the code:
//		- Frans Bouma [FB]
//////////////////////////////////////////////////////////////////////
using System;
using System.Collections.Generic;
using System.Xml;
using System.Reflection;
using System.Collections;
using System.Xml.Serialization;

namespace SD.LLBLGen.Pro.ORMSupportClasses
{
	/// <summary>
	/// Generic class which is used for the columns in the EntityFields collection, which forms the data store of
	/// any Entity class generated by LLBLGen Pro. 
	/// </summary>
	[Serializable]
	public class EntityField2 : IEntityField2, ICloneable, IComparable, IEntityFieldCoreInterpret
	{
		#region Class Member Declarations
		private	string				_alias, _objectAlias;
		private object				_currentValue, _originalValue, _dbValue;
		private bool				_isChanged, _isNull;
		private AggregateFunction	_aggregateFunctionToApply;
		private IExpression			_expressionToApply;
		private IEntityFieldCore	_linkedSuperTypeField;
		private List<IEntityField2>	_linkedSubTypeFields;
		private IFieldInfo			_fieldInfo;
		private int _fakeFieldIndex;			// fieldIndex for a field when the field isn't containing a FieldInfo object but is used for an entity fetch

		[NonSerialized]
		private	bool				_isDiscriminatorColumn;
		[NonSerialized]
		private bool _beginEditIsChangedState;
		#endregion


		/// <summary>
		/// CTor
		/// </summary>
		/// <param name="fieldInfo">The field info.</param>
		public EntityField2( IFieldInfo fieldInfo)
		{
			_fieldInfo = fieldInfo;
			_objectAlias = string.Empty;
			// rest is not necessary to set, including _fakeFieldIndex. _fakeFieldIndex is only used when the field represents an expression or
			// has no fieldinfo, in both cases the fieldindex is set from the outside, i.e. in the entityfields' DefineField routine.
		}


		/// <summary>
		/// Initializes a new instance of the <see cref="EntityField"/> class.
		/// </summary>
		/// <param name="name">The name of the field. Has to be specified</param>
		/// <param name="expressionToApply">The expression to apply.</param>
		public EntityField2( string name, IExpression expressionToApply ) : this(name, expressionToApply, AggregateFunction.None)
		{
		}


		/// <summary>
		/// Initializes a new instance of the <see cref="EntityField"/> class.
		/// </summary>
		/// <param name="name">The name of the field. Has to be specified</param>
		/// <param name="expressionToApply">The expression to apply.</param>
		/// <param name="aggregateFunctionToApply">The aggregate function to apply.</param>
		public EntityField2(string name, IExpression expressionToApply, AggregateFunction aggregateFunctionToApply )
		{
			_fieldInfo = new FieldInfo(name, string.Empty, null, false, false, true, false, 0, 0, 0, 0);
			_objectAlias = string.Empty;
			_aggregateFunctionToApply = aggregateFunctionToApply;
			_expressionToApply = expressionToApply;
			_alias = name;
		}


		/// <summary>
		/// Compares the given entityfield instance with this instance using a value compare with <b>case sensitive</b> comparer logic.
		/// this is done by comparing the name, the source schema, object and column name. If there is any mismatch, the
		/// comparisson is stopped and the result of the mismatching compare is returned.
		/// </summary>
		/// <param name="fieldToCompare">The EntityField to compare with the current value.</param>
		/// <returns>A 32-bit signed integer that indicates the relative order of the comparands. See <see cref="System.IComparable.CompareTo"/>.</returns>
		public int CompareTo(object fieldToCompare)
		{
			IEntityField2 comparedField = fieldToCompare as IEntityField2;

			if(comparedField==null)
			{
				// not an EntityField2
				throw new ArgumentException("fieldToCompare is not of type IEntityField2", "fieldToCompare");
			}

			// compare the passed in field with this instance.
			int compareResult = 0;
			compareResult = this.Name.CompareTo(comparedField.Name);
			if(compareResult != 0)
			{
				// done
				return compareResult;
			}

			compareResult = this.ActualContainingObjectName.CompareTo(comparedField.ActualContainingObjectName);
			if(compareResult != 0)
			{
				return compareResult;
			}
			// compare values
			if((_currentValue == null) || (comparedField.CurrentValue == null))
			{
				if(_currentValue == null)
				{
					if(comparedField.CurrentValue == null)
					{
						compareResult = 0;
					}
					else
					{
						compareResult = -1;
					}
				}
				else
				{
					compareResult = 1;
				}
			}
			else
			{
				compareResult = _currentValue.ToString().CompareTo(comparedField.CurrentValue.ToString());
			}
			return compareResult;
		}


		/// <summary>
		/// Overrides the GetHashCode() method. It will return the hashcode of the value of the field as the hashcode. 
		/// </summary>
		/// <remarks>byte[] typed fields will have all the bytes in their array added together with per byte it's multiplied with the index+1</remarks>
		/// <returns>hashcode of the value of the field.</returns>
		public override int GetHashCode()
		{
			if(_currentValue!=null)
			{
				if(_currentValue is byte[])
				{
					byte[] value = _currentValue as byte[];
					int toReturn = 0;
					for (int i = 0; i < value.Length; i++)
					{
						toReturn += ((int)value[i]) * (i+1);
					}
					return toReturn;
				}
				else
				{
					return _currentValue.GetHashCode();
				}
			}
			else
			{
				return base.GetHashCode();
			}
		}


		/// <summary>
		/// Writes the XML of this Field object to the writer specified
		/// </summary>
		/// <param name="writer">The writer.</param>
		/// <param name="aspects">The aspects.</param>
		internal void WriteXml(XmlWriter writer, XmlFormatAspect aspects)
		{
			bool compactXml = ((aspects & XmlFormatAspect.Compact) == XmlFormatAspect.Compact);
			bool compact25Xml = ((aspects & XmlFormatAspect.Compact25) == XmlFormatAspect.Compact25);
			bool datesInXmlDataType = ((aspects & XmlFormatAspect.DatesInXmlDataType) == XmlFormatAspect.DatesInXmlDataType);
			bool mlInCDataBlocks = ((aspects & XmlFormatAspect.MLTextInCDataBlocks) == XmlFormatAspect.MLTextInCDataBlocks);
			bool verboseXml = !(compact25Xml || compactXml);
			if(compact25Xml && compactXml)
			{
				// only one allowed
				compactXml = false;
			}

			if(compact25Xml)
			{
				if(_currentValue != null)
				{
					// just emit the value
					writer.WriteStartElement(this.Name);		// <fieldName>
					XmlHelper.WriteValueAsStringToXml(this.DataType, _currentValue, verboseXml, !compact25Xml, writer, datesInXmlDataType, mlInCDataBlocks);
					writer.WriteEndElement();	// </fieldName>
				}
				else
				{
					// no field is emitted, skip
				}
			}
			else
			{
				writer.WriteStartElement(this.Name);		// <fieldName>
				writer.WriteStartElement("CurrentValue");	// <CurrentValue>
				XmlHelper.WriteValueAsStringToXml(this.DataType, _currentValue, verboseXml, !compact25Xml, writer, datesInXmlDataType, mlInCDataBlocks);
				writer.WriteEndElement();		// </CurrentValue>

				writer.WriteStartElement("DbValue");		// <DbValue>
				XmlHelper.WriteValueAsStringToXml(this.DataType, _dbValue, verboseXml, !compact25Xml, writer, datesInXmlDataType, mlInCDataBlocks);
				writer.WriteEndElement();		// </DbValue>

				writer.WriteElementString("IsChanged", _isChanged.ToString());
				writer.WriteElementString("IsNull", _isNull.ToString());
				writer.WriteEndElement();	// </fieldName>
			}
		}

		
		/// <summary>
		/// Accepts the value of the current value as the final current value. Original value is discarded
		/// </summary>
		public void AcceptChange()
		{
			if(!_isChanged)
			{
				// no change to accept
				return;
			}

			_originalValue = null;
			_isChanged = false;
		}


		/// <summary>
		/// Rejects the value of the current value and resets current value with the original value, and <see cref="IsChanged"/> will report false.
		/// </summary>
		public void RejectChange()
		{
			if(!_isChanged)
			{
				// no change to reject
				return;
			}

			_currentValue = _originalValue;
			_isChanged = false;
		}


		/// <summary>
		/// Creates a deep copy of this IEntityField2 object
		/// </summary>
		/// <returns>A deep copy of this object</returns>
		public virtual object Clone()
		{
			EntityField2 fieldToReturn = (EntityField2)this.MemberwiseClone();
			// correct linked subtype fields so they're in a new list
			fieldToReturn.CloneLinkedSubTypeFieldsList();
			return fieldToReturn;
		}


		/// <summary>
		/// Overwrites the current value with the value passed. This bypasses value checking and field properties. 
		/// </summary>
		/// <param name="value">Value to store as the current value</param>
		public void ForcedCurrentValueWrite(object value)
		{
			_currentValue = value;
			PropagateChangeToLinkedFields();
		}


		/// <summary>
		/// Overwrites the current value with the value passed. This bypasses value checking and field properties like readonly. 
		/// </summary>
		/// <param name="value">Value to store as the current value</param>
		/// <param name="dbValue">the value read from the database.</param>
		public virtual void ForcedCurrentValueWrite(object value, object dbValue)
		{
			_currentValue = value;
			PropagateChangeToLinkedFields();
			_dbValue = dbValue;
		}


		/// <summary>
		/// Overwrites the current value with the value passed. This bypasses value checking and field properties like readonly. 
		/// Used by internal code only. Do not call this from your code.
		/// </summary>
		/// <param name="value">Value to store as the current value</param>
		/// <param name="dbValue">the value read from the database.</param>
		internal void ForcedCurrentValueWriteInternal(object value, object dbValue)
		{
			_currentValue = value;
			if(_linkedSuperTypeField != null)
			{
				((EntityField2)_linkedSuperTypeField).ForcedCurrentValueWriteFromSubType(value);
			}
			if(_linkedSubTypeFields != null)
			{
				foreach(EntityField2 field in _linkedSubTypeFields)
				{
					field.ForcedCurrentValueWriteFromSuperType(value);
				}
			}
			_dbValue = dbValue;
			_isChanged = false;
			_originalValue = null;
		}


		/// <summary>
		/// Sets the DbValue property with the value passed in. 
		/// </summary>
		/// <param name="value"></param>
		internal void SetDbValue(object value)
		{
			_dbValue = value;
		}


		/// <summary>
		/// Forces a set of the IsChanged flag for this field. 
		/// </summary>
		/// <param name="isChangedValue">new value for IsChanged.</param>
		/// <remarks>Do not call this method from your code. This is an internal method</remarks>
		internal void ForcedChangedWrite(bool isChangedValue)
		{
			_isChanged = isChangedValue;
		}


		/// <summary>
		/// Forcess a set of the IsNull flag
		/// </summary>
		/// <param name="isNull"><see langword="true"/> if [is null]; otherwise, <see langword="false"/>.</param>
		/// <remarks>Do not call this method from your code. This is an internal method</remarks>
		internal void ForcedIsNullWrite(bool isNull)
		{
			_isNull = isNull;
			if(_isNull && (_dbValue != null))
			{
				_dbValue = null;
			}
		}


		/// <summary>
		/// IEditableObject method. Used by databinding.
		/// The field is kept marked changed, in effect, this method is empty.
		/// </summary>
		public void EndEdit()
		{
			// empty
		}


		/// <summary>
		/// IEditableObject method. Used by databinding.
		/// The currentvalue is reset by the original value.
		/// The field's IsChanged state is rolled back as well. 
		/// </summary>
		public void CancelEdit()
		{
			_currentValue = _originalValue;
			_isChanged = _beginEditIsChangedState;
		}

		
		/// <summary>
		/// IEditableObject method. Used by databinding.
		/// Original value is overwritten by currentValue, currentValue keeps its value.
		/// </summary>
		public void BeginEdit()
		{
			_originalValue = _currentValue;
			_beginEditIsChangedState = _isChanged;
		}


		/// <summary>
		/// Forceds the current value write, with a call from a sub type. It will only propagate this call up to supertype linked field, (if any)
		/// </summary>
		/// <param name="value">Value.</param>
		internal void ForcedCurrentValueWriteFromSubType(object value)
		{
			bool valueIsTheSame = FieldUtilities.ValuesAreEqual(_currentValue, value);
			_currentValue = value;
			_isChanged = (!valueIsTheSame) || _isChanged;
			if(_linkedSuperTypeField != null)
			{
				((EntityField2)_linkedSuperTypeField).ForcedCurrentValueWriteFromSubType(value);
			}
		}


		/// <summary>
		/// Forceds the current value write, with a call from the supertype. It will only propagate this call down to subtype linked field, (if any)
		/// </summary>
		/// <param name="value">Value.</param>
		internal void ForcedCurrentValueWriteFromSuperType(object value)
		{
			bool valueIsTheSame = FieldUtilities.ValuesAreEqual(_currentValue, value);
			_currentValue = value;
			_isChanged = (!valueIsTheSame) || _isChanged;
			if(_linkedSubTypeFields != null)
			{
				foreach(EntityField2 field in _linkedSubTypeFields)
				{
					field.ForcedCurrentValueWriteFromSuperType(_currentValue);
				}
			}
		}
		

		/// <summary>
		/// Propagates the change to linked fields.
		/// </summary>
		private void PropagateChangeToLinkedFields()
		{
			// use ForcedCurrentValueWrite to set the linked fields to the same value as this field. ForcedCurrentValueWrite doesn't propagate
			// changes to linked fields (if any).
			PropagateForcedCurrentValueWriteToSuperType(_currentValue);
			PropagateForcedCurrentValueWriteToSubTypes(_currentValue);
		}

		/// <summary>
		/// Sets the discriminator column flag.
		/// </summary>
		/// <param name="value"><see langword="true"/> if [value]; otherwise, <see langword="false"/>.</param>
		internal void SetDiscriminatorColumnFlag(bool value)
		{
			_isDiscriminatorColumn = value;
		}

		/// <summary>
		/// Sets the FieldIndex, if _fieldInfo is null. Used in DefineField.
		/// </summary>
		/// <param name="newIndex">The new index.</param>
		internal void SetFieldIndex(int newIndex)
		{
			if((_fieldInfo == null) || ((_fieldInfo != null) && (_fieldInfo.ContainingObjectName.Length <= 0)))
			{
				_fakeFieldIndex = newIndex;
			}
		}

		/// <summary>
		/// Gets the discriminator column flag.
		/// </summary>
		/// <returns></returns>
		public bool GetDiscriminatorColumnFlag()
		{
			return _isDiscriminatorColumn;
		}
		

		/// <summary>
		/// Determines whether the specified <see cref="T:System.Object"></see> is equal to the current <see cref="T:System.Object"></see>.
		/// </summary>
		/// <param name="obj">The <see cref="T:System.Object"></see> to compare with the current <see cref="T:System.Object"></see>.</param>
		/// <returns>
		/// true if the specified <see cref="T:System.Object"></see> is equal to the current <see cref="T:System.Object"></see>; otherwise, false.
		/// </returns>
		public override bool Equals(object obj)
		{
			return base.Equals(obj);
		}


		/// <summary>
		/// Sets the entity field's ObjectAlias property to the specified value
		/// </summary>
		/// <param name="objectAlias">value to set</param>
		/// <returns>The entity field object the method was called on, for command chaining</returns>
		public EntityField2 SetObjectAlias(string objectAlias)
		{
			this.ObjectAlias = objectAlias;
			return this;
		}

		/// <summary>
		/// Sets the field alias.
		/// </summary>
		/// <param name="fieldAlias">The field alias.</param>
		/// <returns>The entity field object the method was called on, for command chaining</returns>
		public EntityField2 SetFieldAlias( string fieldAlias )
		{
			_alias = fieldAlias;
			return this;
		}

		/// <summary>
		/// Sets the EntityField's AggregateFunctionToApply property
		/// </summary>
		/// <param name="functionToToApply">Function to apply.</param>
		/// <returns>The entity field object the method was called on, for command chaining</returns>
		public EntityField2 SetAggregateFunction(AggregateFunction functionToToApply)
		{
			this.AggregateFunctionToApply = functionToToApply;
			return this;
		}

		/// <summary>
		/// Sets the Entity Field's ExpressionToToApply property
		/// </summary>
		/// <param name="expressionToToApply">Expression to to apply.</param>
		/// <returns>The entity field object the method was called on, for command chaining</returns>
		public EntityField2 SetExpression(IExpression expressionToToApply)
		{
			this.ExpressionToApply = expressionToToApply;
			return this;
		}

		/// <summary>
		/// Propagates the value to the linked fields from supertype
		/// </summary>
		/// <param name="value">Value.</param>
		private void PropagateForcedCurrentValueWriteToSuperType(object value)
		{
			if(_linkedSuperTypeField!=null)
			{
				((EntityField2)_linkedSuperTypeField).ForcedCurrentValueWriteFromSubType(value);
			}
		}

		/// <summary>
		/// Propagates the value to the linked fields from subtypes
		/// </summary>
		/// <param name="value">Value.</param>
		private void PropagateForcedCurrentValueWriteToSubTypes(object value)
		{
			if(_linkedSubTypeFields!=null)
			{
				foreach(EntityField2 field in _linkedSubTypeFields)
				{
					field.ForcedCurrentValueWriteFromSuperType(value);
				}
			}
		}
		

		/// <summary>
		/// Clones the linked sub type fields list so a clone of this field has a new instance of the linkedsubtypefields list (with still the same field objects)
		/// </summary>
		private void CloneLinkedSubTypeFieldsList()
		{
			if((_linkedSubTypeFields!=null) && (_linkedSubTypeFields.Count > 0))
			{
				_linkedSubTypeFields = new List<IEntityField2>(_linkedSubTypeFields);
			}
		}


		#region IEntityFieldCoreInterpret Members
		/// <summary>
		/// Gets the value for the field implementing this interface for the entity passed in.
		/// </summary>
		/// <param name="entity">The entity.</param>
		/// <returns>
		/// the value of the field in the entity passed in. If the field isn't present in the entity passed in, null is returned
		/// If the field's value is Undefined, DBNull.Value is returned.
		/// </returns>
		object IEntityFieldCoreInterpret.GetValue( IEntityCore entity )
		{
			if( _expressionToApply != null )
			{
				// has expression.
				IExpressionInterpret expression = _expressionToApply as IExpressionInterpret;
				if( expression == null )
				{
					throw new ORMInterpretationException( "The expression object set for entity field '" + _alias + "' isn't implementing IExpressionInterpret" );
				}
				return expression.GetValue( entity );
			}
			IEntityField2 fieldFromEntity = ((EntityBase2)entity).Fields[this.Name];
			if(fieldFromEntity == null)
			{
				// this field isn't defined in the entity passed in
				return DBNull.Value;
			}
			if( ((EntityBase2)entity).CallCheckIfCurrentFieldValueIsNull( fieldFromEntity.FieldIndex ) )
			{
				return DBNull.Value;
			}
			return entity.GetCurrentFieldValue(fieldFromEntity.FieldIndex);
		}
		#endregion


////////////////////////////////////////////////
// Operator overloads
////////////////////////////////////////////////

		#region Predicate producing operator overloads
		/// <summary>
		/// Operator overload for the '==' operator to produce a FieldCompareExpressionPredicate to represent leftOperand == rigthOperand
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand.</param>
		/// <returns>A FieldCompareExpressionPredicate</returns>
		public static Predicate operator==(EntityField2 leftOperand, EntityField2 rightOperand)
		{
			return new FieldCompareExpressionPredicate(leftOperand, null, ComparisonOperator.Equal, new Expression(rightOperand));
		}

		/// <summary>
		/// Operator overload for the '!=' operator to produce a FieldCompareExpressionPredicate to represent leftOperand != rigthOperand
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand.</param>
		/// <returns>A FieldCompareExpressionPredicate which is negated</returns>
		public static Predicate operator!=(EntityField2 leftOperand, EntityField2 rightOperand)
		{
			return new FieldCompareExpressionPredicate(leftOperand, null, ComparisonOperator.Equal, new Expression(rightOperand), true);
		}


		/// <summary>
		/// Operator overload for the '&gt;' operator to produce a FieldCompareExpressionPredicate to represent leftOperand &gt; rigthOperand
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand.</param>
		/// <returns>A FieldCompareExpressionPredicate</returns>
		public static Predicate operator>(EntityField2 leftOperand, EntityField2 rightOperand)
		{
			return new FieldCompareExpressionPredicate(leftOperand, null, ComparisonOperator.GreaterThan, new Expression(rightOperand));
		}


		/// <summary>
		/// Operator overload for the '&gt;=' operator to produce a FieldCompareExpressionPredicate to represent leftOperand &gt;= rigthOperand
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand.</param>
		/// <returns>A FieldCompareExpressionPredicate</returns>
		public static Predicate operator>=(EntityField2 leftOperand, EntityField2 rightOperand)
		{
			return new FieldCompareExpressionPredicate(leftOperand, null, ComparisonOperator.GreaterEqual, new Expression(rightOperand));
		}


		/// <summary>
		/// Operator overload for the '&lt;' operator to produce a FieldCompareExpressionPredicate to represent leftOperand &lt; rigthOperand
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand.</param>
		/// <returns>A FieldCompareExpressionPredicate</returns>
		public static Predicate operator<(EntityField2 leftOperand, EntityField2 rightOperand)
		{
			return new FieldCompareExpressionPredicate(leftOperand, null, ComparisonOperator.LesserThan, new Expression(rightOperand));
		}


		/// <summary>
		/// Operator overload for the '&lt;=' operator to produce a FieldCompareExpressionPredicate to represent leftOperand &lt;= rigthOperand
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand.</param>
		/// <returns>A FieldCompareExpressionPredicate</returns>
		public static Predicate operator<=(EntityField2 leftOperand, EntityField2 rightOperand)
		{
			return new FieldCompareExpressionPredicate(leftOperand, null, ComparisonOperator.LessEqual, new Expression(rightOperand));
		}


		/// <summary>
		/// Operator overload for the '==' operator to produce a FieldCompareExpressionPredicate to represent leftOperand == rigthOperand
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand.</param>
		/// <returns>A FieldCompareExpressionPredicate</returns>
		public static Predicate operator ==( EntityField2 leftOperand, EntityProperty rightOperand )
		{
			return new FieldCompareExpressionPredicate( leftOperand, null, ComparisonOperator.Equal, new Expression( rightOperand ) );
		}

		/// <summary>
		/// Operator overload for the '!=' operator to produce a FieldCompareExpressionPredicate to represent leftOperand != rigthOperand
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand.</param>
		/// <returns>A FieldCompareExpressionPredicate which is negated</returns>
		public static Predicate operator !=( EntityField2 leftOperand, EntityProperty rightOperand )
		{
			return new FieldCompareExpressionPredicate( leftOperand, null, ComparisonOperator.Equal, new Expression( rightOperand ), true );
		}


		/// <summary>
		/// Operator overload for the '&gt;' operator to produce a FieldCompareExpressionPredicate to represent leftOperand &gt; rigthOperand
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand.</param>
		/// <returns>A FieldCompareExpressionPredicate</returns>
		public static Predicate operator >( EntityField2 leftOperand, EntityProperty rightOperand )
		{
			return new FieldCompareExpressionPredicate( leftOperand, null, ComparisonOperator.GreaterThan, new Expression( rightOperand ) );
		}


		/// <summary>
		/// Operator overload for the '&gt;=' operator to produce a FieldCompareExpressionPredicate to represent leftOperand &gt;= rigthOperand
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand.</param>
		/// <returns>A FieldCompareExpressionPredicate</returns>
		public static Predicate operator >=( EntityField2 leftOperand, EntityProperty rightOperand )
		{
			return new FieldCompareExpressionPredicate( leftOperand, null, ComparisonOperator.GreaterEqual, new Expression( rightOperand ) );
		}


		/// <summary>
		/// Operator overload for the '&lt;' operator to produce a FieldCompareExpressionPredicate to represent leftOperand &lt; rigthOperand
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand.</param>
		/// <returns>A FieldCompareExpressionPredicate</returns>
		public static Predicate operator <( EntityField2 leftOperand, EntityProperty rightOperand )
		{
			return new FieldCompareExpressionPredicate( leftOperand, null, ComparisonOperator.LesserThan, new Expression( rightOperand ) );
		}


		/// <summary>
		/// Operator overload for the '&lt;=' operator to produce a FieldCompareExpressionPredicate to represent leftOperand &lt;= rigthOperand
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand.</param>
		/// <returns>A FieldCompareExpressionPredicate</returns>
		public static Predicate operator <=( EntityField2 leftOperand, EntityProperty rightOperand )
		{
			return new FieldCompareExpressionPredicate( leftOperand, null, ComparisonOperator.LessEqual, new Expression( rightOperand ) );
		}


		/// <summary>
		/// Operator overload for the '==' operator to produce a FieldCompareRangePredicate. 
		/// </summary>
		/// <param name="field">Field to compare</param>
		/// <param name="values">the values to compare with.</param>
		/// <returns>A FieldCompareRangePredicate</returns>
		public static Predicate operator ==( EntityField2 field, IList values )
		{
			return new FieldCompareRangePredicate(field, null, values);
		}


		/// <summary>
		/// Operator overload for the '!=' operator to produce a FieldCompareRangePredicate. 
		/// </summary>
		/// <param name="field">Field to compare</param>
		/// <param name="values">the values to compare with.</param>
		/// <returns>A FieldCompareRangePredicate which is negated</returns>
		public static Predicate operator !=( EntityField2 field, IList values )
		{
			return new FieldCompareRangePredicate(field, null, true, values);
		}


		/// <summary>
		/// Operator overload for the '==' operator to produce a FieldCompareValue/Null predicate. 
		/// </summary>
		/// <param name="field">Field to compare</param>
		/// <param name="value">the value to compare with. If value is null, a FieldCompareNullPredicate will be created instead.</param>
		/// <returns>A FieldCompareNullPredicate or FieldCompareValuePredicate with the operator ComparisonOperator.Equal</returns>
		public static Predicate operator==(EntityField2 field, object value)
		{
			if((value==null)||(value==System.DBNull.Value))
			{
				return new FieldCompareNullPredicate(field, null);
			}
			else
			{
				if(value is IEntityField2)
				{
					return (field == (EntityField2)value);
				}
				return new FieldCompareValuePredicate(field, null, ComparisonOperator.Equal, value);
			}
		}


		/// <summary>
		/// Operator overload for the '!=' operator to produce a FieldCompareValue/Null predicate. 
		/// </summary>
		/// <param name="field">Field to compare</param>
		/// <param name="value">the value to compare with. If value is null, a FieldCompareNullPredicate will be created instead.</param>
		/// <returns>A FieldCompareNullPredicate or FieldCompareValuePredicate with the operator ComparisonOperator.NotEqual</returns>
		public static Predicate operator!=(EntityField2 field, object value)
		{
			if((value==null)||(value==System.DBNull.Value))
			{
				return new FieldCompareNullPredicate(field, null, true);
			}
			else
			{
				if(value is IEntityField2)
				{
					return (field != (EntityField2)value);
				}
				return new FieldCompareValuePredicate(field, null, ComparisonOperator.NotEqual, value);
			}
		}


		/// <summary>
		/// Operator overload for the '&gt;' operator to produce a FieldCompareValuePredicate. 
		/// </summary>
		/// <param name="field">Field to compare</param>
		/// <param name="value">the value to compare with.</param>
		/// <returns>A FieldCompareValuePredicate with the operator ComparisonOperator.GreaterThan</returns>
		public static Predicate operator>(EntityField2 field, object value)
		{
			if(value is IEntityField2)
			{
				return (field > (EntityField2)value);
			}
			return new FieldCompareValuePredicate(field, null, ComparisonOperator.GreaterThan, value);
		}


		/// <summary>
		/// Operator overload for the '&gt;=' operator to produce a FieldCompareValuePredicate. 
		/// </summary>
		/// <param name="field">Field to compare</param>
		/// <param name="value">the value to compare with.</param>
		/// <returns>A FieldCompareValuePredicate with the operator ComparisonOperator.GreaterEqual</returns>
		public static Predicate operator>=(EntityField2 field, object value)
		{
			if(value is IEntityField2)
			{
				return (field >= (EntityField2)value);
			}
			return new FieldCompareValuePredicate(field, null, ComparisonOperator.GreaterEqual, value);
		}


		/// <summary>
		/// Operator overload for the '&lt;' operator to produce a FieldCompareValuePredicate. 
		/// </summary>
		/// <param name="field">Field to compare</param>
		/// <param name="value">the value to compare with.</param>
		/// <returns>A FieldCompareValuePredicate with the operator ComparisonOperator.LesserThan</returns>
		public static Predicate operator<(EntityField2 field, object value)
		{
			if(value is IEntityField2)
			{
				return (field < (EntityField2)value);
			}
			return new FieldCompareValuePredicate(field, null, ComparisonOperator.LesserThan, value);
		}


		/// <summary>
		/// Operator overload for the '&lt;=' operator to produce a FieldCompareValuePredicate. 
		/// </summary>
		/// <param name="field">Field to compare</param>
		/// <param name="value">the value to compare with.</param>
		/// <returns>A FieldCompareValuePredicate with the operator ComparisonOperator.LessEqual</returns>
		public static Predicate operator<=(EntityField2 field, object value)
		{
			if(value is IEntityField2)
			{
				return (field <= (EntityField2)value);
			}
			return new FieldCompareValuePredicate(field, null, ComparisonOperator.LessEqual, value);
		}


		/// <summary>
		/// Operator overload for the '==' operator to produce a FieldCompareExpression predicate.
		/// </summary>
		/// <param name="field">Field to compare</param>
		/// <param name="toCompareWith">To compare with.</param>
		/// <returns>A FieldCompareExpressionPredicate with operator ComparisonOperator.Equal</returns>
		public static Predicate operator==(EntityField2 field, IExpression toCompareWith)
		{
			return new FieldCompareExpressionPredicate(field, null, ComparisonOperator.Equal, toCompareWith);
		}


		/// <summary>
		/// Operator overload for the '!=' operator to produce a FieldCompareExpression predicate.
		/// </summary>
		/// <param name="field">Field to compare</param>
		/// <param name="toCompareWith">To compare with.</param>
		/// <returns>A FieldCompareExpressionPredicate with operator ComparisonOperator.NotEqual</returns>
		public static Predicate operator!=(EntityField2 field, IExpression toCompareWith)
		{
			return new FieldCompareExpressionPredicate(field, null, ComparisonOperator.NotEqual, toCompareWith);
		}


		/// <summary>
		/// Operator overload for the '&gt;' operator to produce a FieldCompareExpression predicate.
		/// </summary>
		/// <param name="field">Field to compare</param>
		/// <param name="toCompareWith">To compare with.</param>
		/// <returns>A FieldCompareExpressionPredicate with operator ComparisonOperator.GreaterThan</returns>
		public static Predicate operator>(EntityField2 field, IExpression toCompareWith)
		{
			return new FieldCompareExpressionPredicate(field, null, ComparisonOperator.GreaterThan, toCompareWith);
		}


		/// <summary>
		/// Operator overload for the '&gt;=' operator to produce a FieldCompareExpression predicate.
		/// </summary>
		/// <param name="field">Field to compare</param>
		/// <param name="toCompareWith">To compare with.</param>
		/// <returns>A FieldCompareExpressionPredicate with operator ComparisonOperator.GreaterEqual</returns>
		public static Predicate operator>=(EntityField2 field, IExpression toCompareWith)
		{
			return new FieldCompareExpressionPredicate(field, null, ComparisonOperator.GreaterEqual, toCompareWith);
		}


		/// <summary>
		/// Operator overload for the '&lt;' operator to produce a FieldCompareExpression predicate.
		/// </summary>
		/// <param name="field">Field to compare</param>
		/// <param name="toCompareWith">To compare with.</param>
		/// <returns>A FieldCompareExpressionPredicate with operator ComparisonOperator.LesserThan</returns>
		public static Predicate operator<(EntityField2 field, IExpression toCompareWith)
		{
			return new FieldCompareExpressionPredicate(field, null, ComparisonOperator.LesserThan, toCompareWith);
		}


		/// <summary>
		/// Operator overload for the '&lt;=' operator to produce a FieldCompareExpression predicate.
		/// </summary>
		/// <param name="field">Field to compare</param>
		/// <param name="toCompareWith">To compare with.</param>
		/// <returns>A FieldCompareExpressionPredicate with operator ComparisonOperator.LessEqual</returns>
		public static Predicate operator<=(EntityField2 field, IExpression toCompareWith)
		{
			return new FieldCompareExpressionPredicate(field, null, ComparisonOperator.LessEqual, toCompareWith);
		}


		/// <summary>
		/// Operator overload for the '%' operator to produce a FieldLikePredicate.
		/// </summary>
		/// <param name="field">Field to compare</param>
		/// <param name="pattern">Pattern.</param>
		/// <returns>
		/// A FieldLikePredicate 
		/// </returns>
		public static Predicate operator%(EntityField2 field, string pattern)
		{
			return new FieldLikePredicate(field, null, pattern);
		}

		#endregion

		#region Expression producing operator overloads
		/// <summary>
		/// Operator overload for the '+' operator to produce an Expression which represents field + value
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="value">Value.</param>
		/// <returns>
		/// Expression object which represents field + value
		/// </returns>
		public static Expression operator+(EntityField2 leftOperand, object value)
		{
			if(value is IEntityField2)
			{
				return (leftOperand + (EntityField2)value);
			}
			return new Expression(leftOperand, ExOp.Add, value);
		}

		/// <summary>
		/// Operator overload for the '+' operator to produce an Expression which represents field + expression
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand.</param>
		/// <returns>
		/// Expression object which represents field + value
		/// </returns>
		public static Expression operator+(EntityField2 leftOperand, Expression rightOperand)
		{
			return new Expression(leftOperand, ExOp.Add, rightOperand);
		}

		/// <summary>
		/// Operator overload for the '+' operator to produce an Expression which represents field + field2
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand</param>
		/// <returns>Expression object which represents field + value</returns>
		public static Expression operator+(EntityField2 leftOperand, EntityField2 rightOperand)
		{
			return new Expression(leftOperand, ExOp.Add, rightOperand);
		}

		/// <summary>
		/// Operator overload for the '+' operator to produce an Expression which represents field + property
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand</param>
		/// <returns>Expression object which represents field + value</returns>
		public static Expression operator +( EntityField2 leftOperand, EntityProperty rightOperand )
		{
			return new Expression( leftOperand, ExOp.Add, rightOperand );
		}

		/// <summary>
		/// Operator overload for the '+' operator to produce an Expression which represents value + field
		/// </summary>
		/// <param name="value">Value.</param>
		/// <param name="rightOperand">Right operand.</param>
		/// <returns>
		/// Expression object which represents value + field
		/// </returns>
		public static Expression operator+(object value, EntityField2 rightOperand)
		{
			return new Expression(value, ExOp.Add, rightOperand);
		}

		/// <summary>
		/// Operator overload for the '+' operator to produce an Expression which represents expression + field
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand.</param>
		/// <returns></returns>
		public static Expression operator+(Expression leftOperand, EntityField2 rightOperand)
		{
			return new Expression(leftOperand, ExOp.Add, rightOperand);
		}

		/// <summary>
		/// Operator overload for the '*' operator to produce an Expression which represents field * value
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="value">Value.</param>
		/// <returns>
		/// Expression object which represents field * value
		/// </returns>
		public static Expression operator*(EntityField2 leftOperand, object value)
		{
			if(value is IEntityField2)
			{
				return (leftOperand * (EntityField2)value);
			}
			return new Expression(leftOperand, ExOp.Mul, value);
		}

		/// <summary>
		/// Operator overload for the '*' operator to produce an Expression which represents field * expression
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand</param>
		/// <returns>Expression object which represents field * expression</returns>
		public static Expression operator*(EntityField2 leftOperand, Expression rightOperand)
		{
			return new Expression(leftOperand, ExOp.Mul, rightOperand);
		}

		/// <summary>
		/// Operator overload for the '*' operator to produce an Expression which represents field * field2
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand</param>
		/// <returns>Expression object which represents field * field2</returns>
		public static Expression operator*(EntityField2 leftOperand, EntityField2 rightOperand)
		{
			return new Expression(leftOperand, ExOp.Mul, rightOperand);
		}

		/// <summary>
		/// Operator overload for the '*' operator to produce an Expression which represents field * property
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand</param>
		/// <returns>Expression object which represents field * field2</returns>
		public static Expression operator *( EntityField2 leftOperand, EntityProperty rightOperand )
		{
			return new Expression( leftOperand, ExOp.Mul, rightOperand );
		}

		/// <summary>
		/// Operator overload for the '*' operator to produce an Expression which represents value * field
		/// </summary>
		/// <param name="value">Value.</param>
		/// <param name="rightOperand">Right operand.</param>
		/// <returns>
		/// Expression object which represents value * field
		/// </returns>
		public static Expression operator*(object value, EntityField2 rightOperand)
		{
			if(value is IEntityField2)
			{
				return ((EntityField2)value * rightOperand);
			}
			return new Expression(value, ExOp.Mul, rightOperand);
		}

		/// <summary>
		/// Operator overload for the '*' operator to produce an Expression which represents expression * field
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand.</param>
		/// <returns></returns>
		public static Expression operator*(Expression leftOperand, EntityField2 rightOperand)
		{
			return new Expression(leftOperand, ExOp.Mul, rightOperand);
		}

		/// <summary>
		/// Operator overload for the '-' operator to produce an Expression which represents field - value
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="value">Value.</param>
		/// <returns>
		/// Expression object which represents field - value
		/// </returns>
		public static Expression operator-(EntityField2 leftOperand, object value)
		{
			if(value is IEntityField2)
			{
				return (leftOperand - (EntityField2)value);
			}
			return new Expression(leftOperand, ExOp.Sub, value);
		}

		/// <summary>
		/// Operator overload for the '-' operator to produce an Expression which represents field - expression
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand</param>
		/// <returns>Expression object which represents field - expression</returns>
		public static Expression operator-(EntityField2 leftOperand, Expression rightOperand)
		{
			return new Expression(leftOperand, ExOp.Sub, rightOperand);
		}

		/// <summary>
		/// Operator overload for the '-' operator to produce an Expression which represents field - field2
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand</param>
		/// <returns>Expression object which represents field - field2</returns>
		public static Expression operator-(EntityField2 leftOperand, EntityField2 rightOperand)
		{
			return new Expression(leftOperand, ExOp.Sub, rightOperand);
		}

		/// <summary>
		/// Operator overload for the '-' operator to produce an Expression which represents field - property
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand</param>
		/// <returns>Expression object which represents field - field2</returns>
		public static Expression operator -( EntityField2 leftOperand, EntityProperty rightOperand )
		{
			return new Expression( leftOperand, ExOp.Sub, rightOperand );
		}

		/// <summary>
		/// Operator overload for the '-' operator to produce an Expression which represents value - field
		/// </summary>
		/// <param name="value">Value.</param>
		/// <param name="rightOperand">Right operand.</param>
		/// <returns>
		/// Expression object which represents value - field
		/// </returns>
		public static Expression operator-(object value, EntityField2 rightOperand)
		{
			if(value is IEntityField2)
			{
				return ((EntityField2)value - rightOperand);
			}
			return new Expression(value, ExOp.Sub, rightOperand);
		}

		/// <summary>
		/// Operator overload for the '-' operator to produce an Expression which represents expression - field
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand.</param>
		/// <returns></returns>
		public static Expression operator-(Expression leftOperand, EntityField2 rightOperand)
		{
			return new Expression(leftOperand, ExOp.Sub, rightOperand);
		}

		/// <summary>
		/// Operator overload for the '/' operator to produce an Expression which represents field / value
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="value">Value.</param>
		/// <returns>
		/// Expression object which represents field / value
		/// </returns>
		public static Expression operator/(EntityField2 leftOperand, object value)
		{
			if(value is IEntityField2)
			{
				return (leftOperand / (EntityField2)value);
			}
			return new Expression(leftOperand, ExOp.Div, value);
		}

		/// <summary>
		/// Operator overload for the '/' operator to produce an Expression which represents field / expression
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand</param>
		/// <returns>Expression object which represents field / expression</returns>
		public static Expression operator/(EntityField2 leftOperand, Expression rightOperand)
		{
			return new Expression(leftOperand, ExOp.Div, rightOperand);
		}

		/// <summary>
		/// Operator overload for the '/' operator to produce an Expression which represents field / field2
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand</param>
		/// <returns>Expression object which represents field / field2</returns>
		public static Expression operator/(EntityField2 leftOperand, EntityField2 rightOperand)
		{
			return new Expression(leftOperand, ExOp.Div, rightOperand);
		}

		/// <summary>
		/// Operator overload for the '/' operator to produce an Expression which represents field / property
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand</param>
		/// <returns>Expression object which represents field / field2</returns>
		public static Expression operator /( EntityField2 leftOperand, EntityProperty rightOperand )
		{
			return new Expression( leftOperand, ExOp.Div, rightOperand );
		}

		/// <summary>
		/// Operator overload for the '/' operator to produce an Expression which represents value / field
		/// </summary>
		/// <param name="value">Value.</param>
		/// <param name="rightOperand">Right operand.</param>
		/// <returns>
		/// Expression object which represents value / field
		/// </returns>
		public static Expression operator/(object value, EntityField2 rightOperand)
		{
			if(value is IEntityField2)
			{
				return ((EntityField2)value / rightOperand);
			}
			return new Expression(value, ExOp.Div, rightOperand);
		}

		/// <summary>
		/// Operator overload for the '/' operator to produce an Expression which represents expression / field
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand.</param>
		/// <returns></returns>
		public static Expression operator/(Expression leftOperand, EntityField2 rightOperand)
		{
			return new Expression(leftOperand, ExOp.Div, rightOperand);
		}

		#endregion

		#region SortExpression producing operator overloads
		/// <summary>
		/// Operator overload for the '|' operator to concatenate sortoperators to a field
		/// </summary>
		/// <param name="field">Field.</param>
		/// <param name="operatorToUse">Operator to use.</param>
		/// <returns>new SortClause object</returns>
		public static SortClause operator|(EntityField2 field, SortOperator operatorToUse)
		{
			return new SortClause(field, null, operatorToUse);
		}
		#endregion

		#region Class Property Declarations
		/// <summary>
		/// Gets / sets linkedSuperTypeField. Fields of PK/UC's are linked with eachother in a target-per-entity hierarchy. This is managed in
		/// the EntityFields object.
		/// </summary>
		[XmlIgnore]
		public IEntityFieldCore LinkedSuperTypeField
		{
			get
			{
				return _linkedSuperTypeField;
			}
			set
			{
				_linkedSuperTypeField = value;
			}
		}


		/// <summary>
		/// Gets linkedSubTypeFields
		/// </summary>
		[XmlIgnore]
		public List<IEntityField2> LinkedSubTypeFields
		{
			get
			{
				if(_linkedSubTypeFields==null)
				{
					_linkedSubTypeFields = new List<IEntityField2>( 4 );
				}
				return _linkedSubTypeFields;
			}
		}

		/// <summary>
		/// The maximum length of the value of the entityfield (string/binary data). Is ignored for entityfields which hold non-string and non-binary values.
		/// Value initially set for this field is the length of the database column this field is mapped on.
		/// </summary>
		[XmlIgnore]
		public int MaxLength 
		{
			get {return _fieldInfo.MaxLength;}
		}
		
		/// <summary>
		/// The scale of the value for this field. 
		/// Value initially set for this field is the scale of the database column this field is mapped on.
		/// </summary>
		[XmlIgnore]
		public byte Scale 
		{
			get {return _fieldInfo.Scale;}
		}

		/// <summary>
		/// The precision of the value for this field.
		/// Value initially set for this field is the precision of the database column this field is mapped on.
		/// </summary>
		[XmlIgnore]
		public byte Precision 
		{
			get {return _fieldInfo.Precision;}
		}
		
		/// <summary>
		/// The name of the field. Used in XML output. 
		/// </summary>
		[XmlIgnore]
		public string Name
		{
			get { return _fieldInfo.Name; }
		}

		/// <summary>
		/// The alias to use for this field. By default the same as the entity name.
		/// </summary>
		public string Alias
		{
			get
			{
				if(_alias == null)
				{
					if(_fieldInfo == null)
					{
						return string.Empty;
					}
					else
					{
						return _fieldInfo.Name;
					}
				}
				else
				{
					return _alias;
				}
			}
			set
			{
				_alias = value;
			}
		}

		/// <summary>
		/// The original value for this field when the field is changed and the change has not been accepted yet.
		/// </summary>
		internal object OriginalValue
		{
			get { return _originalValue;}
			set { _originalValue = value; }
		}
		
		
		/// <summary>
		/// Gets the current value for this field and sets the new value for this field, by overwriting current value. The value in 
		/// currentValue is discarded, versioning control has to save the original value of currentValue before this property is called. 
		/// </summary>
		/// <remarks>
		/// Calling this property directly will not trigger versioning control,
		/// thus calling this property directly is not recommended. Call <see cref="EntityBase.SetNewFieldValue(string, object)"/> instead.
		/// Type of the new value has to be the same as <see cref="DataType"/>, which is set in the
		/// constructor. If this field is set to readonly, an exception is raised. 
		/// </remarks>
		/// <exception cref="ORMFieldIsReadonlyException">The field is set to readonly and not part of the PK.</exception>
		/// <exception cref="ORMValueTypeMismatchException">The value specified is not of the same <see cref="DataType"/> as this field.</exception>
		public object CurrentValue
		{
			get { return _currentValue; }
			set 
			{ 
				if(value!=null)
				{
					if( (this.DataType != typeof( object )) && (value.GetType() != this.DataType) && !this.DataType.IsInstanceOfType( value ) )
					{
						// see if _dataType has an op_Implicit defined which accepts value.GetType(). if so the type can be converted and the value is
						// ok, otherwise the value isn't valid and can't be used. 
						MethodInfo implicitConverterMethod = this.DataType.GetMethod( "op_Implicit", new Type[] { value.GetType() } );
						if(implicitConverterMethod==null)
						{
							// can't be converted to type of this field, error
							throw new ORMValueTypeMismatchException( "The value " + value.ToString() + " is of type '" + value.GetType().ToString() + "' while the field is of type '" + this.DataType + "'" );
						}
					}
				}
				
				if(this.IsReadOnly && !this.IsPrimaryKey)
				{
					throw new ORMFieldIsReadonlyException("The field is marked readonly and cannot be changed.");
				}

				_currentValue = value; 
				_isChanged = true;
				PropagateChangeToLinkedFields();
			}
		}

		/// <summary>
		/// The <see cref="System.Type"/> of the values of this field.
		/// </summary>
		[XmlIgnore]
		public Type DataType
		{
			get { return _fieldInfo.DataType; }
		}
		
		/// <summary>
		/// If set to true, in the constructor, this field will end up in the PrimaryKey field list of the containing IEntityFields object.
		/// </summary>
		[XmlIgnore]
		public bool IsPrimaryKey 
		{
			get { return _fieldInfo.IsPrimaryKey; }
		}
		
		/// <summary>
		/// If set to true, in the constructor, no changes can be made to this field. 
		/// </summary>
		[XmlIgnore]
		public bool IsReadOnly
		{
			get { return _fieldInfo.IsReadOnly; }
		}

		/// <summary>
		/// If the value of this field is changed, this property is set to true. Set when <see cref="CurrentValue"/> receives a valid value. Set to 
		/// false when <see cref="AcceptChange"/> is called succesfully.
		/// </summary>
		public bool IsChanged
		{
			get { return _isChanged; }
			set { _isChanged = value; }
		}
		
		/// <summary>
		/// If the original value in the column for this entityfield is DBNull (NULL), this parameter should be set to true, otherwise to false.
		/// In BL Logic, it's impractical to work with NULL values, so these are converted to workable values. The developer can still determine if
		/// the original value was DBNull by checking this field. Using NULL values is not recommended. 
		/// </summary>
		public bool IsNull
		{
			get { return _isNull; }
			set	{ _isNull = value;}
		}

		/// <summary>
		/// Gets the field index related to this IEntityField2, so the field can be used to retrieve the field index.
		/// </summary>
		[XmlIgnore]
		public int FieldIndex 
		{
			get 
			{
				if((_fieldInfo == null) || ((_fieldInfo != null) && (_fieldInfo.ContainingObjectName.Length <= 0)))
				{
					return _fakeFieldIndex;
				}
				else
				{
					return _fieldInfo.FieldIndex;
				}
			}
		}

		/// <summary>
		/// Name of the containing object this field belongs to (entity or typed view). This name is required to retrieve persistence information in Adapter
		/// Set via constructor. This name is also used by EntityRelation to determine alias - table connection.
		/// </summary>
		[XmlIgnore]
		public string ContainingObjectName 
		{
			get { return _fieldInfo.ContainingObjectName;}
		}

		/// <summary>
		/// Gets the value read from the database for this field. Use this field in optimistic concurrency predicates.
		/// Set by ForcedCurrentValueWrite(object, value) by the object fetcher logic.
		/// </summary>
		public object DbValue 
		{
			get { return _dbValue; }
		}

		
		/// <summary>
		/// Alias for the object containing the field this entity field is mapped on. Used in typed list selection lists.
		/// </summary>
		public string ObjectAlias 
		{
			get
			{
				return _objectAlias;
			}
			set { _objectAlias = value; }
		}

		/// <summary>
		/// The aggregate function to apply on this field in a select query. Ignored in INSERT/UPDATE/DELETE queries. 
		/// Designed to be used in TypedList/TypedView classes.
		/// </summary>
		public AggregateFunction AggregateFunctionToApply 
		{
			get { return _aggregateFunctionToApply;}
			set { _aggregateFunctionToApply=value;}
		}

		/// <summary>
		/// The expression to apply to this field in a select list, update statement or predicate. 
		/// Expression is applied before AggregateFunctionToApply.
		/// </summary>
		public IExpression ExpressionToApply 
		{
			get { return _expressionToApply;}
			set { _expressionToApply = value;}
		}

		/// <summary>
		/// If set to true, in the constructor, this field is part of a foreign key. This field is not used in LLBLGen Pro's code, however
		/// can be useful in user code.
		/// </summary>
		[XmlIgnore]
		public bool IsForeignKey 
		{
			get { return _fieldInfo.IsForeignKey;}
		}

		/// <summary>
		/// Will be true if this field can be set to NULL in the database, false otherwise. The Field Validation logic in an entity will use this
		/// flag to check if the field indeed can be set to NULL or not. Set by constructor.
		/// </summary>
		[XmlIgnore]
		public bool IsNullable 
		{
			get { return _fieldInfo.IsNullable;}
		}


		/// <summary>
		/// The name of the object this field is currently in. Differs only from ContainingObjectName if the field instance is in a subtype while it is
		/// originally defined in a supertype.
		/// </summary>
		/// <example>EmployeeEntity.Name and a subtype, ClerkEntity, inherits this field. For ClerkEntity.Name ContainingObjectName is still 'EmployeeEntity'
		/// however ActualContainingObjectName is 'ClerkEntity'.</example>
		[XmlIgnore]
		public string ActualContainingObjectName
		{
			get { return _fieldInfo.ActualContainingObjectName; }
		}

		/// <summary>
		/// Flag to signal if the field is in a multi-target entity. Used for alias production during query building in scenario's with inheritance.
		/// </summary>
		[XmlIgnore]
		public bool IsInMultiTargetEntity
		{
			get { return _fieldInfo.IsInMultiTargetEntity; }
		}
		#endregion
	}
}
