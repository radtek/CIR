//////////////////////////////////////////////////////////////////////
// LLBLGen Pro is (c) 2002-2007 Solutions Design. All rights reserved.
// http://www.llblgen.com
// The sourcecode for the ORM Support classes is released as BSD2 licensed 
// open source, so licensees of LLBLGen Pro can modify, update and/or extend it. 
// Distribution of this sourcecode and binary compiled versions of this sourcecode
// are licensed to LLBLGen Pro licensees using the following license below.
//////////////////////////////////////////////////////////////////////
// COPYRIGHTS:
// Copyright (c)2002-2006 Solutions Design. All rights reserved.
// 
// The ORM Support classes library sourcecode is released under the following license: (BSD2)
// ----------------------------------------------------------------------
// Redistribution and use in source and binary forms, with or without modification, 
// are permitted provided that the following conditions are met: 
//
// 1) Redistributions of source code must retain the above copyright notice, this list of 
//    conditions and the following disclaimer. 
// 2) Redistributions in binary form must reproduce the above copyright notice, this list of 
//    conditions and the following disclaimer in the documentation and/or other materials 
//    provided with the distribution. 
// 
// THIS SOFTWARE IS PROVIDED BY SOLUTIONS DESIGN ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, 
// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SOLUTIONS DESIGN OR CONTRIBUTORS BE LIABLE FOR 
// ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR 
// BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, 
// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE 
// USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
//
// The views and conclusions contained in the software and documentation are those of the authors 
// and should not be interpreted as representing official policies, either expressed or implied, 
// of Solutions Design. 
//
//////////////////////////////////////////////////////////////////////
// Contributers to the code:
//		- Frans Bouma [FB]
//////////////////////////////////////////////////////////////////////
using System;
using System.Collections;
using System.IO;
using System.Xml;
using System.Xml.Serialization;
using System.ComponentModel;
using System.Reflection;

namespace SD.LLBLGen.Pro.ORMSupportClasses
{
	/// <summary>
	/// Generic class which is used for the columns in the EntityFields collection, which forms the data store of
	/// any Entity class generated by LLBLGen Pro. 
	/// </summary>
	[Serializable]
	public class EntityField: IEntityField, ICloneable, IComparable, IEntityFieldCoreInterpret
	{
		#region Class Member Declarations
		private	string				_objectAlias, _alias;
		private object				_currentValue, _originalValue, _dbValue;
		private bool				_isChanged, _isNull;
		private AggregateFunction	_aggregateFunctionToApply;
		private IExpression			_expressionToApply;
		private IEntityFieldCore	_linkedSuperTypeField;
		private IFieldInfo			_fieldInfo;
		private IFieldPersistenceInfo _fieldPersistenceInfo;
		private ArrayList			_linkedSubTypeFields;
		private int					_fakeFieldIndex;			// fieldIndex for a field when the field isn't containing a FieldInfo object but is used for an entity fetch

		[NonSerialized]
		private	bool				_isDiscriminatorColumn;
		[NonSerialized]
		private bool				_beginEditIsChangedState;
		#endregion
		
		/// <summary>
		/// Initializes a new instance of the <see cref="EntityField"/> class.
		/// </summary>
		/// <param name="fieldInfo">The field info.</param>
		/// <param name="fieldPersistenceInfo">The field persistence info.</param>
		public EntityField( IFieldInfo fieldInfo, IFieldPersistenceInfo fieldPersistenceInfo)
		{
			_fieldInfo = fieldInfo;
			_fieldPersistenceInfo = fieldPersistenceInfo;
			_objectAlias = string.Empty;
			_linkedSubTypeFields = new ArrayList();
			// rest is not necessary to set, including _fakeFieldIndex. _fakeFieldIndex is only used when the field represents an expression or
			// has no fieldinfo, in both cases the fieldindex is set from the outside, i.e. in the entityfields' DefineField routine.
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="EntityField"/> class.
		/// </summary>
		/// <param name="name">The name of the field. Has to be specified</param>
		/// <param name="expressionToApply">The expression to apply.</param>
		public EntityField( string name, IExpression expressionToApply ) : this(name, expressionToApply, AggregateFunction.None)
		{
		}


		/// <summary>
		/// Initializes a new instance of the <see cref="EntityField"/> class.
		/// </summary>
		/// <param name="name">The name of the field. Has to be specified</param>
		/// <param name="expressionToApply">The expression to apply.</param>
		/// <param name="aggregateFunctionToApply">The aggregate function to apply.</param>
		public EntityField( string name, IExpression expressionToApply, AggregateFunction aggregateFunctionToApply )
		{
			_fieldInfo = new FieldInfo(name, string.Empty, null, false, false, true, false, 0, 0, 0, 0);
			_fieldPersistenceInfo = new FieldPersistenceInfo();
			_objectAlias = string.Empty;
			_expressionToApply = expressionToApply;
			_aggregateFunctionToApply=aggregateFunctionToApply;
			_linkedSubTypeFields = new ArrayList();
			if(_fieldInfo != null)
			{
				_alias = _fieldInfo.Name;
				_fakeFieldIndex = _fieldInfo.FieldIndex;
			}
			else
			{
				_alias = string.Empty;
			} 		
		}


		/// <summary>
		/// Compares the given entityfield instance with this instance using a value compare with <b>case sensitive</b> comparer logic.
		/// this is done by comparing the name, the source schema, object and column name. If there is any mismatch, the
		/// comparisson is stopped and the result of the mismatching compare is returned.
		/// </summary>
		/// <param name="fieldToCompare">The EntityField to compare with the current value.</param>
		/// <returns>A 32-bit signed integer that indicates the relative order of the comparands. See <see cref="System.IComparable.CompareTo"/>.</returns>
		public int CompareTo(object fieldToCompare)
		{
			IEntityField comparedField = fieldToCompare as IEntityField;

			if(comparedField==null)
			{
				// not an EntityField2
				throw new ArgumentException("fieldToCompare is not of type IEntityField", "fieldToCompare");
			}

			// compare the passed in field with this instance.
			int compareResult = 0;
			compareResult = this.Name.CompareTo(comparedField.Name);
			if(compareResult!=0)
			{
				// done
				return compareResult;
			}

			compareResult = this.SourceSchemaName.CompareTo(comparedField.SourceSchemaName);
			if(compareResult!=0)
			{
				// done
				return compareResult;
			}

			compareResult = this.SourceObjectName.CompareTo(comparedField.SourceObjectName);
			if(compareResult!=0)
			{
				// done
				return compareResult;
			}

			compareResult = this.SourceColumnName.CompareTo(comparedField.SourceColumnName);
			if(compareResult!=0)
			{
				// done
				return compareResult;
			}

			compareResult = this.ActualContainingObjectName.CompareTo(comparedField.ActualContainingObjectName);
			if(compareResult != 0)
			{
				return compareResult;
			}
			// compare values
			if((_currentValue == null) || (comparedField.CurrentValue == null))
			{
				if(_currentValue == null)
				{
					if(comparedField.CurrentValue == null)
					{
						compareResult = 0;
					}
					else
					{
						compareResult = -1;
					}
				}
				else
				{
					compareResult = 1;
				}
			}
			else
			{
				compareResult = _currentValue.ToString().CompareTo(comparedField.CurrentValue.ToString());
			}
			return compareResult;
		}


		/// <summary>
		/// Overrides the GetHashCode() method. It will return the hashcode of the value of the field as the hashcode. 
		/// </summary>
		/// <returns>hashcode of the value of the field.</returns>
		public override int GetHashCode()
		{
			if(_currentValue!=null)
			{
				if(_currentValue is byte[])
				{
					byte[] value = _currentValue as byte[];
					int toReturn = 0;
					for (int i = 0; i < value.Length; i++)
					{
						toReturn += ((int)value[i]) * (i+1);
					}
					return toReturn;
				}
				else
				{
					return _currentValue.GetHashCode();
				}
			}
			else
			{
				return base.GetHashCode();
			}
		}

		/// <summary>
		/// Converts this EntityField to an XmlNode. 
		/// </summary>
		/// <returns>This EntityField in XmlNode format</returns>
		public virtual XmlNode ToXml()
		{
#if !CF
			MemoryStream output = new MemoryStream(512);
			XmlSerializer serializer = new XmlSerializer(typeof(EntityField));
			StreamWriter outputWriter = new StreamWriter(output);

			serializer.Serialize(outputWriter, this);
			output.Position = 0;

			XmlDocument newNode = new XmlDocument();
			newNode.Load(output);
			return newNode.SelectSingleNode("/*");
#else
			throw new NotSupportedException("Use WriteXml instead");
#endif
		}

		/// <summary>
		/// Converts this EntityField to an XmlNode. 
		/// </summary>
		/// <param name="aspects">The aspect flags to control the format of the XML produced</param>
		/// <param name="parentDocument">the XmlDocument which will contain the node this method will return. This document is required
		/// to create the new node object</param>
		/// <param name="entityFieldNode">The output parameter which will represent this EntityField as XmlNode</param>
		public void WriteXml(XmlFormatAspect aspects, XmlDocument parentDocument, out XmlNode entityFieldNode)
		{
			bool compactXml = ((aspects & XmlFormatAspect.Compact)==XmlFormatAspect.Compact);
			bool datesInXmlDataType = ((aspects & XmlFormatAspect.DatesInXmlDataType)==XmlFormatAspect.DatesInXmlDataType);
			bool mlInCDataBlocks = ((aspects & XmlFormatAspect.MLTextInCDataBlocks)==XmlFormatAspect.MLTextInCDataBlocks);

			entityFieldNode = parentDocument.CreateNode(XmlNodeType.Element, this.Name, "");
			
			XmlHelper nodeCreator = new XmlHelper();

			// create child nodes and attributes for this node.
			XmlNode childNode = nodeCreator.AddNode(entityFieldNode, "CurrentValue");

			string valueTypeName = "Unknown";

			// the value of this field can be of a variety of types. Some types require extra treatment before they can be
			// put as a value in an XmlNode.
			string valueAsString = String.Empty;

			bool valueInCDataBlock = false;
			if(_currentValue!=null)
			{
				valueTypeName = this.DataType.UnderlyingSystemType.FullName.ToString();
				switch(valueTypeName)
				{
					case "System.String":
						valueAsString = _currentValue.ToString();
						if(mlInCDataBlocks)
						{
							valueInCDataBlock = (valueAsString.IndexOfAny(new char[] {'<', '>'})>=0);
						}
						break;
					case "System.DateTime":
						if(datesInXmlDataType)
						{
							valueAsString = ((DateTime)_currentValue).ToString("yyyy-MM-ddTHH:mm:ss.fffffffzzzzzz");
						}
						else
						{
							valueAsString = ((DateTime)_currentValue).Ticks.ToString();
						}
						break;
					case "System.Byte[]":
						// special case, base64encode it
						byte[] valueToConvert = (byte[])_currentValue;
						valueAsString = Convert.ToBase64String(valueToConvert, 0, valueToConvert.Length);
						break;
					default:
						valueAsString = _currentValue.ToString();
						break;
				}
			}
			if( ((_currentValue==null)&&compactXml) || !compactXml)
			{
				nodeCreator.AddAttribute(childNode, "Type", valueTypeName);
			}
			if(valueInCDataBlock)
			{
				childNode.AppendChild(parentDocument.CreateCDataSection(valueAsString));
			}
			else
			{
				childNode.AppendChild(parentDocument.CreateTextNode(valueAsString));
			}

			childNode = nodeCreator.AddNode(entityFieldNode, "DbValue");
			valueTypeName = "Unknown";

			// the value of this field can be of a variety of types. Some types require extra treatment before they can be
			// put as a value in an XmlNode.
			valueAsString = String.Empty;

			if(_dbValue!=null)
			{
				valueTypeName = this.DataType.UnderlyingSystemType.FullName.ToString();
				switch(valueTypeName)
				{
					case "System.String":
						valueAsString = _dbValue.ToString();
						if(mlInCDataBlocks)
						{
							valueInCDataBlock = (valueAsString.IndexOfAny(new char[] {'<', '>'})>=0);
						}
						break;
					case "System.DateTime":
						if(datesInXmlDataType)
						{
							valueAsString = ((DateTime)_dbValue).ToString("yyyy-MM-ddTHH:mm:ss.fffffffzzzzzz");
						}
						else
						{
							valueAsString = ((DateTime)_dbValue).Ticks.ToString();
						}
						break;
					case "System.Byte[]":
						// special case, base64encode it
						byte[] valueToConvert = (byte[])_dbValue;
						valueAsString = Convert.ToBase64String(valueToConvert, 0, valueToConvert.Length);
						break;
					default:
						valueAsString = _dbValue.ToString();
						break;
				}
			}
			if( ((_dbValue==null)&&compactXml) || !compactXml)
			{
				nodeCreator.AddAttribute(childNode, "Type", valueTypeName);
			}

			if(valueInCDataBlock)
			{
				childNode.AppendChild(parentDocument.CreateCDataSection(valueAsString));
			}
			else
			{
				childNode.AppendChild(parentDocument.CreateTextNode(valueAsString));
			}

			childNode = nodeCreator.AddNode(entityFieldNode, "IsChanged", _isChanged.ToString());
			if(!compactXml)
			{
				nodeCreator.AddAttribute(childNode, "Type", "System.Boolean");
			}

			childNode = nodeCreator.AddNode(entityFieldNode, "IsNull", _isNull.ToString());
			if(!compactXml)
			{
				nodeCreator.AddAttribute(childNode, "Type", "System.Boolean");
			}
		}


		
		/// <summary>
		/// Accepts the value of the current value as the final current value. Original value is discarded
		/// </summary>
		internal void AcceptChange()
		{
			if(!_isChanged)
			{
				// no change to accept
				return;
			}

			_originalValue = null;
			_isChanged = false;
		}


		/// <summary>
		/// Rejects the value of the current value and resets current value with the original value, and <see cref="IsChanged"/> will report false.
		/// </summary>
		internal void RejectChange()
		{
			if(!_isChanged)
			{
				// no change to reject
				return;
			}

			_currentValue = _originalValue;
			_isChanged = false;
		}


		/// <summary>
		/// Creates a deep copy of this IEntityField object
		/// </summary>
		/// <returns>A deep copy of this object</returns>
		public virtual object Clone()
		{
			EntityField fieldToReturn = (EntityField)this.MemberwiseClone();
			// correct linked subtype fields so they're in a new list
			fieldToReturn.CloneLinkedSubTypeFieldsList();
			return fieldToReturn;
		}


		/// <summary>
		/// Overwrites the current value with the value passed. This bypasses value checking and field properties like readonly. 
		/// </summary>
		/// <param name="value">Value to store as the current value</param>
		public void ForcedCurrentValueWrite(object value)
		{
			_currentValue = value;
			PropagateChangeToLinkedFields();
		}

		/// <summary>
		/// Overwrites the current value with the value passed. This bypasses value checking and field properties like readonly. 
		/// </summary>
		/// <param name="value">Value to store as the current value</param>
		/// <param name="dbValue">the value read from the database.</param>
		public virtual void ForcedCurrentValueWrite(object value, object dbValue)
		{
			_currentValue = value;
			PropagateChangeToLinkedFields();
			_dbValue = dbValue;
		}


		/// <summary>
		/// Overwrites the current value with the value passed. This bypasses value checking and field properties like readonly. 
		/// Used by internal code only. Do not call this from your code.
		/// </summary>
		/// <param name="value">Value to store as the current value</param>
		/// <param name="dbValue">the value read from the database.</param>
		internal void ForcedCurrentValueWriteInternal(object value, object dbValue)
		{
			_currentValue = value;
			if(_linkedSuperTypeField != null)
			{
				((EntityField)_linkedSuperTypeField).ForcedCurrentValueWriteFromSubType(value);
			}
			foreach(EntityField field in _linkedSubTypeFields)
			{
				field.ForcedCurrentValueWriteFromSuperType(value);
			}
			_dbValue = dbValue;
			_isChanged = false;
			_originalValue = null;
		}


		/// <summary>
		/// Forceds the current value write, with a call from a sub type. It will only propagate this call up to supertype linked field, (if any)
		/// </summary>
		/// <param name="value">Value.</param>
		internal void ForcedCurrentValueWriteFromSubType(object value)
		{
			bool valueIsTheSame = FieldUtilities.ValuesAreEqual(_currentValue, value);
			_currentValue = value;
			_isChanged = (!valueIsTheSame) || _isChanged;
			PropagateForcedCurrentValueWriteToSuperType(value);
		}


		/// <summary>
		/// Forceds the current value write, with a call from the supertype. It will only propagate this call down to subtype linked field, (if any)
		/// </summary>
		/// <param name="value">Value.</param>
		internal void ForcedCurrentValueWriteFromSuperType(object value)
		{
			bool valueIsTheSame = FieldUtilities.ValuesAreEqual(_currentValue, value);
			_currentValue = value;
			_isChanged = (!valueIsTheSame) || _isChanged;
			PropagateForcedCurrentValueWriteToSubTypes(value);
		}


		/// <summary>
		/// Sets the DbValue property with the value passed in. 
		/// </summary>
		/// <param name="value"></param>
		internal void SetDbValue(object value)
		{
			_dbValue = value;
		}

	
		/// <summary>
		/// Forces a set of the IsChanged flag for this field. 
		/// </summary>
		/// <param name="isChangedValue">new value for IsChanged.</param>
		/// <remarks>Do not call this method from your code. This is an internal method</remarks>
		internal void ForcedChangedWrite(bool isChangedValue)
		{
			_isChanged = isChangedValue;
		}


		/// <summary>
		/// Forcess a set of the IsNull flag
		/// </summary>
		/// <param name="isNull"><see langword="true"/> if [is null]; otherwise, <see langword="false"/>.</param>
		/// <remarks>Do not call this method from your code. This is an internal method</remarks>
		internal void ForcedIsNullWrite(bool isNull)
		{
			_isNull = isNull;
		}


		/// <summary>
		/// IEditableObject method. Used by databinding.
		/// The field is kept marked changed, in effect, this method is empty.
		/// </summary>
		public void EndEdit()
		{
			// empty
		}


		/// <summary>
		/// IEditableObject method. Used by databinding.
		/// The currentvalue is reset by the original value.
		/// The field's IsChanged state is rolled back as well. 
		/// </summary>
		public void CancelEdit()
		{
			_currentValue = _originalValue;
			_isChanged = _beginEditIsChangedState;
		}

		
		/// <summary>
		/// IEditableObject method. Used by databinding.
		/// Original value is overwritten by currentValue, currentValue keeps its value.
		/// </summary>
		public void BeginEdit()
		{
			_originalValue = _currentValue;
			_beginEditIsChangedState = _isChanged;
		}


		/// <summary>
		/// Propagates the change to linked fields.
		/// </summary>
		private void PropagateChangeToLinkedFields()
		{
			// use ForcedCurrentValueWrite to set the linked fields to the same value as this field. ForcedCurrentValueWrite doesn't propagate
			// changes to linked fields (if any).
			PropagateForcedCurrentValueWriteToSuperType(_currentValue);
			PropagateForcedCurrentValueWriteToSubTypes(_currentValue);
		}


		/// <summary>
		/// Sets the discriminator column flag.
		/// </summary>
		/// <param name="value"><see langword="true"/> if [value]; otherwise, <see langword="false"/>.</param>
		internal void SetDiscriminatorColumnFlag(bool value)
		{
			_isDiscriminatorColumn = value;
		}

		/// <summary>
		/// Sets the FieldIndex, if _fieldInfo is null. Used in DefineField.
		/// </summary>
		/// <param name="newIndex">The new index.</param>
		internal void SetFieldIndex(int newIndex)
		{
			if((_fieldInfo == null) || ((_fieldInfo != null) && (_fieldInfo.ContainingObjectName.Length <= 0)))
			{
				_fakeFieldIndex = newIndex;
			}
		}
		
		/// <summary>
		/// Gets the discriminator column flag.
		/// </summary>
		/// <returns></returns>
		public bool GetDiscriminatorColumnFlag()
		{
			return _isDiscriminatorColumn;
		}


		
		/// <summary>
		/// Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
		/// </summary>
		/// <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:System.Object"/>.</param>
		/// <returns>
		/// 	<see langword="true"/> if the specified <see cref="T:System.Object"/> is equal to the
		/// current <see cref="T:System.Object"/>; otherwise, <see langword="false"/>.
		/// </returns>
		public override bool Equals(object obj)
		{
			return base.Equals(obj);
		}


		/// <summary>
		/// Sets the entity field's ObjectAlias property to the specified value
		/// </summary>
		/// <param name="objectAlias">value to set</param>
		/// <returns>The entity field object the method was called on, for command chaining</returns>
		public EntityField SetObjectAlias(string objectAlias)
		{
			this.ObjectAlias = objectAlias;
			return this;
		}


		/// <summary>
		/// Sets the EntityField's AggregateFunctionToApply property
		/// </summary>
		/// <param name="functionToToApply">Function to apply.</param>
		/// <returns>The entity field object the method was called on, for command chaining</returns>
		public EntityField SetAggregateFunction(AggregateFunction functionToToApply)
		{
			this.AggregateFunctionToApply = functionToToApply;
			return this;
		}

		/// <summary>
		/// Sets the Entity Field's ExpressionToToApply property
		/// </summary>
		/// <param name="expressionToToApply">Expression to to apply.</param>
		/// <returns>The entity field object the method was called on, for command chaining</returns>
		public EntityField SetExpression(IExpression expressionToToApply)
		{
			this.ExpressionToApply = expressionToToApply;
			return this;
		}

		/// <summary>
		/// Propagates the value to the linked fields from supertype
		/// </summary>
		/// <param name="value">Value.</param>
		private void PropagateForcedCurrentValueWriteToSuperType(object value)
		{
			if(_linkedSuperTypeField!=null)
			{
				((EntityField)_linkedSuperTypeField).ForcedCurrentValueWriteFromSubType(value);
			}
		}

		/// <summary>
		/// Propagates the value to the linked fields from subtypes
		/// </summary>
		/// <param name="value">Value.</param>
		private void PropagateForcedCurrentValueWriteToSubTypes(object value)
		{
			foreach(EntityField field in _linkedSubTypeFields)
			{
				field.ForcedCurrentValueWriteFromSuperType(value);
			}
		}


		/// <summary>
		/// Clones the linked sub type fields list so a clone of this field has a new instance of the linkedsubtypefields list (with still the same field objects)
		/// </summary>
		private void CloneLinkedSubTypeFieldsList()
		{
			if((_linkedSubTypeFields != null) && (_linkedSubTypeFields.Count > 0))
			{
				_linkedSubTypeFields = new ArrayList(_linkedSubTypeFields);
			}
		}


		#region IEntityFieldCoreInterpret Members
		/// <summary>
		/// Gets the value for the field implementing this interface for the entity passed in.
		/// </summary>
		/// <param name="entity">The entity.</param>
		/// <returns>
		/// the value of the field in the entity passed in. If the field isn't present in the entity passed in, null is returned.
		/// If the field is 'undefined', DBNull.Value is returned.
		/// </returns>
		object IEntityFieldCoreInterpret.GetValue( IEntityCore entity )
		{
			if(_expressionToApply!=null)
			{
				// has expression.
				IExpressionInterpret expression = _expressionToApply as IExpressionInterpret;
				if(expression==null)
				{
					throw new ORMInterpretationException("The expression object set for entity field '" + _alias + "' isn't implementing IExpressionInterpret");
				}
				return expression.GetValue(entity);
			}
			IEntityField fieldFromEntity = ((EntityBase)entity).Fields[this.Name];
			if(fieldFromEntity == null)
			{
				// this field isn't defined in the entity passed in
				return DBNull.Value;
			}
			if( ((EntityBase)entity).CallCheckIfCurrentFieldValueIsNull( fieldFromEntity.FieldIndex ) )
			{
				return DBNull.Value;
			}
			return entity.GetCurrentFieldValue( fieldFromEntity.FieldIndex );
		}
		#endregion

		////////////////////////////////////////////////
		// Operator overloads
		////////////////////////////////////////////////

		#region Predicate producing operator overloads
		/// <summary>
		/// Operator overload for the '==' operator to produce a FieldCompareExpressionPredicate to represent leftOperand == rigthOperand
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand.</param>
		/// <returns>A FieldCompareExpressionPredicate</returns>
		public static Predicate operator==(EntityField leftOperand, EntityField rightOperand)
		{
			return new FieldCompareExpressionPredicate(leftOperand, ComparisonOperator.Equal, new Expression(rightOperand));
		}

		/// <summary>
		/// Operator overload for the '!=' operator to produce a FieldCompareExpressionPredicate to represent leftOperand != rigthOperand
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand.</param>
		/// <returns>A FieldCompareExpressionPredicate which is negated</returns>
		public static Predicate operator!=(EntityField leftOperand, EntityField rightOperand)
		{
			return new FieldCompareExpressionPredicate(leftOperand, ComparisonOperator.Equal, new Expression(rightOperand), true);
		}


		/// <summary>
		/// Operator overload for the '&gt;' operator to produce a FieldCompareExpressionPredicate to represent leftOperand &gt; rigthOperand
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand.</param>
		/// <returns>A FieldCompareExpressionPredicate</returns>
		public static Predicate operator>(EntityField leftOperand, EntityField rightOperand)
		{
			return new FieldCompareExpressionPredicate(leftOperand, ComparisonOperator.GreaterThan, new Expression(rightOperand));
		}


		/// <summary>
		/// Operator overload for the '&gt;=' operator to produce a FieldCompareExpressionPredicate to represent leftOperand &gt;= rigthOperand
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand.</param>
		/// <returns>A FieldCompareExpressionPredicate</returns>
		public static Predicate operator>=(EntityField leftOperand, EntityField rightOperand)
		{
			return new FieldCompareExpressionPredicate(leftOperand, ComparisonOperator.GreaterEqual, new Expression(rightOperand));
		}


		/// <summary>
		/// Operator overload for the '&lt;' operator to produce a FieldCompareExpressionPredicate to represent leftOperand &lt; rigthOperand
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand.</param>
		/// <returns>A FieldCompareExpressionPredicate</returns>
		public static Predicate operator<(EntityField leftOperand, EntityField rightOperand)
		{
			return new FieldCompareExpressionPredicate(leftOperand, ComparisonOperator.LesserThan, new Expression(rightOperand));
		}


		/// <summary>
		/// Operator overload for the '&lt;=' operator to produce a FieldCompareExpressionPredicate to represent leftOperand &lt;= rigthOperand
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand.</param>
		/// <returns>A FieldCompareExpressionPredicate</returns>
		public static Predicate operator<=(EntityField leftOperand, EntityField rightOperand)
		{
			return new FieldCompareExpressionPredicate(leftOperand, ComparisonOperator.LessEqual, new Expression(rightOperand));
		}


		/// <summary>
		/// Operator overload for the '==' operator to produce a FieldCompareExpressionPredicate to represent leftOperand == rigthOperand
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand.</param>
		/// <returns>A FieldCompareExpressionPredicate</returns>
		public static Predicate operator ==( EntityField leftOperand, EntityProperty rightOperand )
		{
			return new FieldCompareExpressionPredicate( leftOperand, ComparisonOperator.Equal, new Expression( rightOperand ) );
		}

		/// <summary>
		/// Operator overload for the '!=' operator to produce a FieldCompareExpressionPredicate to represent leftOperand != rigthOperand
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand.</param>
		/// <returns>A FieldCompareExpressionPredicate which is negated</returns>
		public static Predicate operator !=( EntityField leftOperand, EntityProperty rightOperand )
		{
			return new FieldCompareExpressionPredicate( leftOperand, ComparisonOperator.Equal, new Expression( rightOperand ), true );
		}


		/// <summary>
		/// Operator overload for the '&gt;' operator to produce a FieldCompareExpressionPredicate to represent leftOperand &gt; rigthOperand
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand.</param>
		/// <returns>A FieldCompareExpressionPredicate</returns>
		public static Predicate operator >( EntityField leftOperand, EntityProperty rightOperand )
		{
			return new FieldCompareExpressionPredicate( leftOperand, ComparisonOperator.GreaterThan, new Expression( rightOperand ) );
		}


		/// <summary>
		/// Operator overload for the '&gt;=' operator to produce a FieldCompareExpressionPredicate to represent leftOperand &gt;= rigthOperand
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand.</param>
		/// <returns>A FieldCompareExpressionPredicate</returns>
		public static Predicate operator >=( EntityField leftOperand, EntityProperty rightOperand )
		{
			return new FieldCompareExpressionPredicate( leftOperand, ComparisonOperator.GreaterEqual, new Expression( rightOperand ) );
		}


		/// <summary>
		/// Operator overload for the '&lt;' operator to produce a FieldCompareExpressionPredicate to represent leftOperand &lt; rigthOperand
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand.</param>
		/// <returns>A FieldCompareExpressionPredicate</returns>
		public static Predicate operator <( EntityField leftOperand, EntityProperty rightOperand )
		{
			return new FieldCompareExpressionPredicate( leftOperand, ComparisonOperator.LesserThan, new Expression( rightOperand ) );
		}


		/// <summary>
		/// Operator overload for the '&lt;=' operator to produce a FieldCompareExpressionPredicate to represent leftOperand &lt;= rigthOperand
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand.</param>
		/// <returns>A FieldCompareExpressionPredicate</returns>
		public static Predicate operator <=( EntityField leftOperand, EntityProperty rightOperand )
		{
			return new FieldCompareExpressionPredicate( leftOperand, ComparisonOperator.LessEqual, new Expression( rightOperand ) );
		}


		/// <summary>
		/// Operator overload for the '==' operator to produce a FieldCompareRangePredicate. 
		/// </summary>
		/// <param name="field">Field to compare</param>
		/// <param name="values">the values to compare with.</param>
		/// <returns>A FieldCompareRangePredicate</returns>
		public static Predicate operator==(EntityField field, Array values)
		{
			return new FieldCompareRangePredicate(field, values);
		}


		/// <summary>
		/// Operator overload for the '!=' operator to produce a FieldCompareRangePredicate. 
		/// </summary>
		/// <param name="field">Field to compare</param>
		/// <param name="values">the values to compare with.</param>
		/// <returns>A FieldCompareRangePredicate which is negated</returns>
		public static Predicate operator!=(EntityField field, Array values)
		{
			return new FieldCompareRangePredicate(field, true, values);
		}


		/// <summary>
		/// Operator overload for the '==' operator to produce a FieldCompareRangePredicate. 
		/// </summary>
		/// <param name="field">Field to compare</param>
		/// <param name="values">the values to compare with.</param>
		/// <returns>A FieldCompareRangePredicate</returns>
		public static Predicate operator==(EntityField field, ArrayList values)
		{
			return new FieldCompareRangePredicate(field, values);
		}


		/// <summary>
		/// Operator overload for the '!=' operator to produce a FieldCompareRangePredicate. 
		/// </summary>
		/// <param name="field">Field to compare</param>
		/// <param name="values">the values to compare with.</param>
		/// <returns>A FieldCompareRangePredicate which is negated</returns>
		public static Predicate operator!=(EntityField field, ArrayList values)
		{
			return new FieldCompareRangePredicate(field, true, values);
		}


		/// <summary>
		/// Operator overload for the '==' operator to produce a FieldCompareValue/Null predicate. 
		/// </summary>
		/// <param name="field">Field to compare</param>
		/// <param name="value">the value to compare with. If value is null, a FieldCompareNullPredicate will be created instead.</param>
		/// <returns>A FieldCompareNullPredicate or FieldCompareValuePredicate with the operator ComparisonOperator.Equal</returns>
		public static Predicate operator==(EntityField field, object value)
		{
			if((value==null)||(value==System.DBNull.Value))
			{
				return new FieldCompareNullPredicate(field);
			}
			else
			{
				if(value is IEntityField)
				{
					return (field == (EntityField)value);
				}
				return new FieldCompareValuePredicate(field, ComparisonOperator.Equal, value);
			}
		}


		/// <summary>
		/// Operator overload for the '!=' operator to produce a FieldCompareValue/Null predicate. 
		/// </summary>
		/// <param name="field">Field to compare</param>
		/// <param name="value">the value to compare with. If value is null, a FieldCompareNullPredicate will be created instead.</param>
		/// <returns>A FieldCompareNullPredicate or FieldCompareValuePredicate with the operator ComparisonOperator.NotEqual</returns>
		public static Predicate operator!=(EntityField field, object value)
		{
			if((value==null)||(value==System.DBNull.Value))
			{
				return new FieldCompareNullPredicate(field, true);
			}
			else
			{
				if(value is IEntityField)
				{
					return (field != (EntityField)value);
				}
				return new FieldCompareValuePredicate(field, ComparisonOperator.NotEqual, value);
			}
		}


		/// <summary>
		/// Operator overload for the '&gt;' operator to produce a FieldCompareValuePredicate. 
		/// </summary>
		/// <param name="field">Field to compare</param>
		/// <param name="value">the value to compare with.</param>
		/// <returns>A FieldCompareValuePredicate with the operator ComparisonOperator.GreaterThan</returns>
		public static Predicate operator>(EntityField field, object value)
		{
			if(value is IEntityField)
			{
				return (field > (EntityField)value);
			}
			return new FieldCompareValuePredicate(field, ComparisonOperator.GreaterThan, value);
		}


		/// <summary>
		/// Operator overload for the '&gt;=' operator to produce a FieldCompareValuePredicate. 
		/// </summary>
		/// <param name="field">Field to compare</param>
		/// <param name="value">the value to compare with.</param>
		/// <returns>A FieldCompareValuePredicate with the operator ComparisonOperator.GreaterEqual</returns>
		public static Predicate operator>=(EntityField field, object value)
		{
			if(value is IEntityField)
			{
				return (field >= (EntityField)value);
			}
			return new FieldCompareValuePredicate(field, ComparisonOperator.GreaterEqual, value);
		}


		/// <summary>
		/// Operator overload for the '&lt;' operator to produce a FieldCompareValuePredicate. 
		/// </summary>
		/// <param name="field">Field to compare</param>
		/// <param name="value">the value to compare with.</param>
		/// <returns>A FieldCompareValuePredicate with the operator ComparisonOperator.LesserThan</returns>
		public static Predicate operator<(EntityField field, object value)
		{
			if(value is IEntityField)
			{
				return (field < (EntityField)value);
			}
			return new FieldCompareValuePredicate(field, ComparisonOperator.LesserThan, value);
		}


		/// <summary>
		/// Operator overload for the '&lt;=' operator to produce a FieldCompareValuePredicate. 
		/// </summary>
		/// <param name="field">Field to compare</param>
		/// <param name="value">the value to compare with.</param>
		/// <returns>A FieldCompareValuePredicate with the operator ComparisonOperator.LessEqual</returns>
		public static Predicate operator<=(EntityField field, object value)
		{
			if(value is IEntityField)
			{
				return (field <= (EntityField)value);
			}
			return new FieldCompareValuePredicate(field, ComparisonOperator.LessEqual, value);
		}


		/// <summary>
		/// Operator overload for the '==' operator to produce a FieldCompareExpression predicate.
		/// </summary>
		/// <param name="field">Field to compare</param>
		/// <param name="toCompareWith">To compare with.</param>
		/// <returns>A FieldCompareExpressionPredicate with operator ComparisonOperator.Equal</returns>
		public static Predicate operator==(EntityField field, IExpression toCompareWith)
		{
			return new FieldCompareExpressionPredicate(field, ComparisonOperator.Equal, toCompareWith);
		}


		/// <summary>
		/// Operator overload for the '!=' operator to produce a FieldCompareExpression predicate.
		/// </summary>
		/// <param name="field">Field to compare</param>
		/// <param name="toCompareWith">To compare with.</param>
		/// <returns>A FieldCompareExpressionPredicate with operator ComparisonOperator.NotEqual</returns>
		public static Predicate operator!=(EntityField field, IExpression toCompareWith)
		{
			return new FieldCompareExpressionPredicate(field, ComparisonOperator.NotEqual, toCompareWith);
		}


		/// <summary>
		/// Operator overload for the '&gt;' operator to produce a FieldCompareExpression predicate.
		/// </summary>
		/// <param name="field">Field to compare</param>
		/// <param name="toCompareWith">To compare with.</param>
		/// <returns>A FieldCompareExpressionPredicate with operator ComparisonOperator.GreaterThan</returns>
		public static Predicate operator>(EntityField field, IExpression toCompareWith)
		{
			return new FieldCompareExpressionPredicate(field, ComparisonOperator.GreaterThan, toCompareWith);
		}


		/// <summary>
		/// Operator overload for the '&gt;=' operator to produce a FieldCompareExpression predicate.
		/// </summary>
		/// <param name="field">Field to compare</param>
		/// <param name="toCompareWith">To compare with.</param>
		/// <returns>A FieldCompareExpressionPredicate with operator ComparisonOperator.GreaterEqual</returns>
		public static Predicate operator>=(EntityField field, IExpression toCompareWith)
		{
			return new FieldCompareExpressionPredicate(field, ComparisonOperator.GreaterEqual, toCompareWith);
		}


		/// <summary>
		/// Operator overload for the '&lt;' operator to produce a FieldCompareExpression predicate.
		/// </summary>
		/// <param name="field">Field to compare</param>
		/// <param name="toCompareWith">To compare with.</param>
		/// <returns>A FieldCompareExpressionPredicate with operator ComparisonOperator.LesserThan</returns>
		public static Predicate operator<(EntityField field, IExpression toCompareWith)
		{
			return new FieldCompareExpressionPredicate(field, ComparisonOperator.LesserThan, toCompareWith);
		}


		/// <summary>
		/// Operator overload for the '&lt;=' operator to produce a FieldCompareExpression predicate.
		/// </summary>
		/// <param name="field">Field to compare</param>
		/// <param name="toCompareWith">To compare with.</param>
		/// <returns>A FieldCompareExpressionPredicate with operator ComparisonOperator.LessEqual</returns>
		public static Predicate operator<=(EntityField field, IExpression toCompareWith)
		{
			return new FieldCompareExpressionPredicate(field, ComparisonOperator.LessEqual, toCompareWith);
		}


		/// <summary>
		/// Operator overload for the '%' operator to produce a FieldLikePredicate.
		/// </summary>
		/// <param name="field">Field to compare</param>
		/// <param name="pattern">Pattern.</param>
		/// <returns>
		/// A FieldLikePredicate 
		/// </returns>
		public static Predicate operator%(EntityField field, string pattern)
		{
			return new FieldLikePredicate(field, pattern);
		}

		#endregion

		#region Expression producing operator overloads
		/// <summary>
		/// Operator overload for the '+' operator to produce an Expression which represents field + value
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="value">Value.</param>
		/// <returns>
		/// Expression object which represents field + value
		/// </returns>
		public static Expression operator+(EntityField leftOperand, object value)
		{
			if(value is IEntityField)
			{
				return (leftOperand + (EntityField)value);
			}
			return new Expression(leftOperand, ExOp.Add, value);
		}

		/// <summary>
		/// Operator overload for the '+' operator to produce an Expression which represents field + expression
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand.</param>
		/// <returns>
		/// Expression object which represents field + value
		/// </returns>
		public static Expression operator+(EntityField leftOperand, Expression rightOperand)
		{
			return new Expression(leftOperand, ExOp.Add, rightOperand);
		}

		/// <summary>
		/// Operator overload for the '+' operator to produce an Expression which represents field + field2
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand</param>
		/// <returns>Expression object which represents field + value</returns>
		public static Expression operator+(EntityField leftOperand, EntityField rightOperand)
		{
			return new Expression(leftOperand, ExOp.Add, rightOperand);
		}

		/// <summary>
		/// Operator overload for the '+' operator to produce an Expression which represents field + property
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand</param>
		/// <returns>Expression object which represents field + value</returns>
		public static Expression operator +( EntityField leftOperand, EntityProperty rightOperand )
		{
			return new Expression( leftOperand, ExOp.Add, rightOperand );
		}

		/// <summary>
		/// Operator overload for the '+' operator to produce an Expression which represents value + field
		/// </summary>
		/// <param name="value">Value.</param>
		/// <param name="rightOperand">Right operand.</param>
		/// <returns>
		/// Expression object which represents value + field
		/// </returns>
		public static Expression operator+(object value, EntityField rightOperand)
		{
			if(value is IEntityField)
			{
				return ((EntityField)value + rightOperand);
			}
			return new Expression(value, ExOp.Add, rightOperand);
		}

		/// <summary>
		/// Operator overload for the '+' operator to produce an Expression which represents expression + field
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand.</param>
		/// <returns></returns>
		public static Expression operator+(Expression leftOperand, EntityField rightOperand)
		{
			return new Expression(leftOperand, ExOp.Add, rightOperand);
		}

		/// <summary>
		/// Operator overload for the '*' operator to produce an Expression which represents field * value
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="value">Value.</param>
		/// <returns>
		/// Expression object which represents field * value
		/// </returns>
		public static Expression operator*(EntityField leftOperand, object value)
		{
			if(value is IEntityField)
			{
				return (leftOperand * (EntityField)value);
			}
			return new Expression(leftOperand, ExOp.Mul, value);
		}

		/// <summary>
		/// Operator overload for the '*' operator to produce an Expression which represents field * expression
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand</param>
		/// <returns>Expression object which represents field * expression</returns>
		public static Expression operator*(EntityField leftOperand, Expression rightOperand)
		{
			return new Expression(leftOperand, ExOp.Mul, rightOperand);
		}

		/// <summary>
		/// Operator overload for the '*' operator to produce an Expression which represents field * field2
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand</param>
		/// <returns>Expression object which represents field * field2</returns>
		public static Expression operator*(EntityField leftOperand, EntityField rightOperand)
		{
			return new Expression(leftOperand, ExOp.Mul, rightOperand);
		}

		/// <summary>
		/// Operator overload for the '*' operator to produce an Expression which represents field * property
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand</param>
		/// <returns>Expression object which represents field * field2</returns>
		public static Expression operator *( EntityField leftOperand, EntityProperty rightOperand )
		{
			return new Expression( leftOperand, ExOp.Mul, rightOperand );
		}

		/// <summary>
		/// Operator overload for the '*' operator to produce an Expression which represents value * field
		/// </summary>
		/// <param name="value">Value.</param>
		/// <param name="rightOperand">Right operand.</param>
		/// <returns>
		/// Expression object which represents value * field
		/// </returns>
		public static Expression operator*(object value, EntityField rightOperand)
		{
			if(value is IEntityField)
			{
				return ((EntityField)value * rightOperand);
			}
			return new Expression(value, ExOp.Mul, rightOperand);
		}

		/// <summary>
		/// Operator overload for the '*' operator to produce an Expression which represents expression * field
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand.</param>
		/// <returns></returns>
		public static Expression operator*(Expression leftOperand, EntityField rightOperand)
		{
			return new Expression(leftOperand, ExOp.Mul, rightOperand);
		}

		/// <summary>
		/// Operator overload for the '-' operator to produce an Expression which represents field - value
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="value">Value.</param>
		/// <returns>
		/// Expression object which represents field - value
		/// </returns>
		public static Expression operator-(EntityField leftOperand, object value)
		{
			if(value is IEntityField)
			{
				return (leftOperand - (EntityField)value);
			}
			return new Expression(leftOperand, ExOp.Sub, value);
		}

		/// <summary>
		/// Operator overload for the '-' operator to produce an Expression which represents field - expression
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand</param>
		/// <returns>Expression object which represents field - expression</returns>
		public static Expression operator-(EntityField leftOperand, Expression rightOperand)
		{
			return new Expression(leftOperand, ExOp.Sub, rightOperand);
		}

		/// <summary>
		/// Operator overload for the '-' operator to produce an Expression which represents field - field2
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand</param>
		/// <returns>Expression object which represents field - field2</returns>
		public static Expression operator-(EntityField leftOperand, EntityField rightOperand)
		{
			return new Expression(leftOperand, ExOp.Sub, rightOperand);
		}

		/// <summary>
		/// Operator overload for the '-' operator to produce an Expression which represents field - property
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand</param>
		/// <returns>Expression object which represents field - field2</returns>
		public static Expression operator -( EntityField leftOperand, EntityProperty rightOperand )
		{
			return new Expression( leftOperand, ExOp.Sub, rightOperand );
		}

		/// <summary>
		/// Operator overload for the '-' operator to produce an Expression which represents value - field
		/// </summary>
		/// <param name="value">Value.</param>
		/// <param name="rightOperand">Right operand.</param>
		/// <returns>
		/// Expression object which represents value - field
		/// </returns>
		public static Expression operator-(object value, EntityField rightOperand)
		{
			if(value is IEntityField)
			{
				return ((EntityField)value - rightOperand);
			}
			return new Expression(value, ExOp.Sub, rightOperand);
		}

		/// <summary>
		/// Operator overload for the '-' operator to produce an Expression which represents expression - field
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand.</param>
		/// <returns></returns>
		public static Expression operator-(Expression leftOperand, EntityField rightOperand)
		{
			return new Expression(leftOperand, ExOp.Sub, rightOperand);
		}

		/// <summary>
		/// Operator overload for the '/' operator to produce an Expression which represents field / value
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="value">Value.</param>
		/// <returns>
		/// Expression object which represents field / value
		/// </returns>
		public static Expression operator/(EntityField leftOperand, object value)
		{
			if(value is IEntityField)
			{
				return (leftOperand / (EntityField)value);
			}
			return new Expression(leftOperand, ExOp.Div, value);
		}

		/// <summary>
		/// Operator overload for the '/' operator to produce an Expression which represents field / expression
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand</param>
		/// <returns>Expression object which represents field / expression</returns>
		public static Expression operator/(EntityField leftOperand, Expression rightOperand)
		{
			return new Expression(leftOperand, ExOp.Div, rightOperand);
		}

		/// <summary>
		/// Operator overload for the '/' operator to produce an Expression which represents field / field2
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand</param>
		/// <returns>Expression object which represents field / field2</returns>
		public static Expression operator/(EntityField leftOperand, EntityField rightOperand)
		{
			return new Expression(leftOperand, ExOp.Div, rightOperand);
		}

		/// <summary>
		/// Operator overload for the '/' operator to produce an Expression which represents field / property
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand</param>
		/// <returns>Expression object which represents field / field2</returns>
		public static Expression operator /( EntityField leftOperand, EntityProperty rightOperand )
		{
			return new Expression( leftOperand, ExOp.Div, rightOperand );
		}

		/// <summary>
		/// Operator overload for the '/' operator to produce an Expression which represents value / field
		/// </summary>
		/// <param name="value">Value.</param>
		/// <param name="rightOperand">Right operand.</param>
		/// <returns>
		/// Expression object which represents value / field
		/// </returns>
		public static Expression operator/(object value, EntityField rightOperand)
		{
			if(value is IEntityField)
			{
				return ((EntityField)value / rightOperand);
			}
			return new Expression(value, ExOp.Div, rightOperand);
		}

		/// <summary>
		/// Operator overload for the '/' operator to produce an Expression which represents expression / field
		/// </summary>
		/// <param name="leftOperand">Left operand.</param>
		/// <param name="rightOperand">Right operand.</param>
		/// <returns></returns>
		public static Expression operator/(Expression leftOperand, EntityField rightOperand)
		{
			return new Expression(leftOperand, ExOp.Div, rightOperand);
		}

		#endregion

		#region SortExpression producing operator overloads
		/// <summary>
		/// Operator overload for the '|' operator to concatenate sortoperators to a field
		/// </summary>
		/// <param name="field">Field.</param>
		/// <param name="operatorToUse">Operator to use.</param>
		/// <returns>new SortClause object</returns>
		public static SortClause operator|(EntityField field, SortOperator operatorToUse)
		{
			return new SortClause(field, operatorToUse);
		}
		#endregion

		#region Class Property Declarations
		/// <summary>
		/// The .NET type of the field in the DB. This value is used to convert a currentvalue back to this type using TypeConverterToUse. 
		/// </summary>
		public Type ActualDotNetType 
		{ 
			get { return _fieldPersistenceInfo.ActualDotNetType; }
		}
		
		/// <summary>
		/// Gets / sets linkedSuperTypeField. Fields of PK/UC's are linked with eachother in a target-per-entity hierarchy. This is managed in
		/// the EntityFields object.
		/// </summary>
		public IEntityFieldCore LinkedSuperTypeField
		{
			get
			{
				return _linkedSuperTypeField;
			}
			set
			{
				_linkedSuperTypeField = value;
			}
		}


		/// <summary>
		/// Gets linkedSubTypeFields
		/// </summary>
		public ArrayList LinkedSubTypeFields
		{
			get
			{
				return _linkedSubTypeFields;
			}
		}

		/// <summary>
		/// The name of the catalog the SourceSchemaName is located in. 
		/// </summary>
		[XmlIgnore]
		public string SourceCatalogName
		{
			get
			{
				return _fieldPersistenceInfo.SourceCatalogName;
			}
		}


		/// <summary>
		/// The name of the schema which holds <see cref="SourceObjectName"/>. Schema is used to generate SQL on the fly. 
		/// A common schema name in SqlServer is f.e. 'dbo'.
		/// </summary>
		[XmlIgnore]
		public string SourceSchemaName 
		{
			get { return _fieldPersistenceInfo.SourceSchemaName; }
		}
			
		/// <summary>
		/// The name of the source object which holds <see cref="SourceColumnName"/>. Can be a view or a table. Used to generate SQL on the fly.
		/// </summary>
		[XmlIgnore]
		public string SourceObjectName 
		{
			get { return _fieldPersistenceInfo.SourceObjectName; }
		}
			

		/// <summary>
		/// The name of the corresponding column in a view or table for this entityfield. This name is used to map a column in a resultset onto the entity field.
		/// Used for update/insert operations on the column
		/// </summary>
		[XmlIgnore]
		public string SourceColumnName 
		{
			get { return _fieldPersistenceInfo.SourceColumnName; }
		}
		
		/// <summary>
		/// The maximum length of the value of this entityfield (string/binary data). Is ignored for entityfields which hold non-string and non-binary values.
		/// ColumnMaxLength
		/// Used for update/insert operations on the column
		/// </summary>
		[XmlIgnore]
		public int SourceColumnMaxLength
		{
			get { return _fieldPersistenceInfo.SourceColumnMaxLength; }
		}
		
		/// <summary>
		/// The type of the Column mapped onto the EntityField. The value stored here is the integer representation of the enum value of the type, f.e.
		/// SqlDbType.Int or OracleType.Int16
		/// Used for update/insert operations on the column
		/// </summary>
		[XmlIgnore]
		public int SourceColumnDbType
		{
			get { return _fieldPersistenceInfo.SourceColumnDbType; }
		}
		
		/// <summary>
		/// Flag if the Column mapped onto the entityfield is nullable or not. 
		/// Used for update/insert operations on the column
		/// </summary>
		[XmlIgnore]
		public bool SourceColumnIsNullable
		{
			get { return _fieldPersistenceInfo.SourceColumnIsNullable; }
		}
		
		/// <summary>
		/// The scale of the Column mapped onto the entityfield.
		/// Used for update/insert operations on the column
		/// </summary>
		[XmlIgnore]
		public byte SourceColumnScale
		{
			get { return _fieldPersistenceInfo.SourceColumnScale; }
		}
		
		/// <summary>
		/// The precision of the Column mapped onto the entityfield.
		/// Used for update/insert operations on the column
		/// </summary>
		[XmlIgnore]
		public byte SourceColumnPrecision
		{
			get { return _fieldPersistenceInfo.SourceColumnPrecision; }
		}

		/// <summary>
		/// The name of the field.
		/// </summary>
		[XmlIgnore]
		public string Name
		{
			get { return _fieldInfo.Name; }
		}

		/// <summary>
		/// The alias to use for this field. Only used when this field object is part of a typed list. 
		/// </summary>
		public string Alias 
		{
			get
			{
				if(_alias == null)
				{
					if(_fieldInfo == null)
					{
						return string.Empty;
					}
					else
					{
						return _fieldInfo.Name;
					}
				}
				else
				{
					return _alias;
				}
			}
			set
			{
				_alias = value;
			}
		}


		/// <summary>
		/// The original value for this field when the field is changed and the change has not been accepted yet.
		/// </summary>
		internal object OriginalValue
		{
			get { return _originalValue;}
			set { _originalValue = value; }
		}
		
		
		/// <summary>
		/// Gets the current value for this field and sets the new value for this field, by overwriting current value. The value in 
		/// currentValue is discarded, versioning control has to save the original value of currentValue before this property is called. 
		/// </summary>
		/// <remarks>
		/// Calling this property directly will not trigger versioning control,
		/// thus calling this property directly is not recommended. Call <see cref="EntityBase.SetNewFieldValue(string, object)"/> instead.
		/// Type of the new value has to be the same as <see cref="DataType"/>, which is set in the
		/// constructor. If this field is set to readonly, an exception is raised. 
		/// </remarks>
		/// <exception cref="ORMFieldIsReadonlyException">The field is set to readonly and can't be changed.</exception>
		/// <exception cref="ORMValueTypeMismatchException">The value specified is not of the same <see cref="DataType"/> as this field.</exception>
		public object CurrentValue
		{
			get { return _currentValue; }
			set 
			{
				if(value!=null)
				{
					if((this.DataType!= typeof(object)) && (value.GetType() != this.DataType) && !this.DataType.IsInstanceOfType(value))
					{
						// see if this.DataType has an op_Implicit defined which accepts value.GetType(). if so the type can be converted and the value is
						// ok, otherwise the value isn't valid and can't be used. 
						MethodInfo implicitConverterMethod = this.DataType.GetMethod("op_Implicit", new Type[] {value.GetType()});
						if(implicitConverterMethod==null)
						{
							throw new ORMValueTypeMismatchException("The value " + value.ToString() + " is of type '" + value.GetType().ToString() + "' while the field is of type '" + this.DataType + "'");
						}
					}
				}

				if(this.IsReadOnly)
				{
					throw new ORMFieldIsReadonlyException("The field is marked readonly and cannot be changed.");
				}

				_currentValue = value; 
				_isChanged = true;
				PropagateChangeToLinkedFields();
			}
		}

		/// <summary>
		/// The <see cref="System.Type"/> of the values of this field.
		/// </summary>
		[XmlIgnore]
		public Type DataType
		{
			get { return _fieldInfo.DataType; }
		}
		
		/// <summary>
		/// If set to true, in the constructor, no changes can be made to this field. 
		/// </summary>
		[XmlIgnore]
		public bool IsReadOnly
		{
			get { return _fieldInfo.IsReadOnly; }
		}
		
		/// <summary>
		/// If set to true, in the constructor, this field will end up in the PrimaryKey field list of the containing IEntityFields object.
		/// </summary>
		[XmlIgnore]
		public bool IsPrimaryKey 
		{
			get { return _fieldInfo.IsPrimaryKey; }
		}

		/// <summary>
		/// If the value of this field is changed, this property is set to true. Set when <see cref="CurrentValue"/> receives a valid value. Set to 
		/// false when <see cref="AcceptChange"/> is called succesfully.
		/// </summary>
		public bool IsChanged
		{
			get { return _isChanged; }
			set { _isChanged = value; }
		}
		
		/// <summary>
		/// Will be true if this field can be set to NULL in the database, false otherwise. The Field Validation logic in an entity will use this
		/// flag to check if the field indeed can be set to NULL or not.
		/// For selfservicing entities, this flag returns the same value as SourceColumnIsNullable.
		/// </summary>
		public bool IsNullable 
		{
			get { return _fieldInfo.IsNullable; }
		}

		/// <summary>
		/// If the original value in the column for this entityfield is DBNull (NULL), this parameter should be set to true, otherwise to false.
		/// In BL Logic, it's impractical to work with NULL values, so these are converted to workable values. The developer can still determine if
		/// the original value was DBNull by checking this field. Using NULL values is not recommended. 
		/// </summary>
		public bool IsNull
		{
			get { return _isNull; }
			set	{ _isNull = value;}
		}

		/// <summary>
		/// If set to true, the Dynamic Query Engine (DQE) will assume the field is an Identity field and will act accordingly (i.e.: as the target database
		/// handles Identity fields: SqlServer will generate a new value itself, Oracle wants to have a sequence input.
		/// </summary>
		[XmlIgnore]
		public bool IsIdentity 
		{
			get { return _fieldPersistenceInfo.IsIdentity ; }
		}

		/// <summary>
		/// If <see cref="IsIdentity"/> is set to true, this property has to be set to the name of the sequence which supplies the value for the EntityField's
		/// corresponding table field. On SqlServer this is @@IDENTITY or SCOPE_IDENTITY() and only used when the row is succesfully inserted, however on Oracle
		/// f.e. this value is used to specify a new value and to retrieve the new value. Is undefined when <see cref="IsIdentity"/> is set to false.
		/// </summary>
		[XmlIgnore]
		public string IdentityValueSequenceName 
		{
			get { return _fieldPersistenceInfo.IdentityValueSequenceName; } 
		}

		/// <summary>
		/// Gets the field index related to this IEntityField, so the field can be used to retrieve the field index.
		/// </summary>
		[XmlIgnore]
		public int FieldIndex 
		{
			get 
			{
				if((_fieldInfo == null) || ((_fieldInfo != null) && (_fieldInfo.ContainingObjectName.Length <= 0)))
				{
					return _fakeFieldIndex;
				}
				else
				{
					return _fieldInfo.FieldIndex;
				}
			}
		}
		
		/// <summary>
		/// Gets the value read from the database for this field. Use this field in optimistic concurrency predicates.
		/// Set by ForcedCurrentValueWrite(object, value) by the object fetcher logic.
		/// </summary>
		public object DbValue 
		{
			get { return _dbValue; }
		}

		/// <summary>
		/// Name of the containing object this field belongs to (entity or typed view). This name is required to retrieve persistence information in Adapter
		/// Set via constructor. This name is also used by EntityRelation to determine alias - table connection.
		/// </summary>
		[XmlIgnore]
		public string ContainingObjectName 
		{
			get { return _fieldInfo.ContainingObjectName;}
		}

		/// <summary>
		/// Alias for the object containing the field this entity field is mapped on. Used in typed list selection lists.
		/// </summary>
		public string ObjectAlias 
		{
			get 
			{
				return _objectAlias;
			}
			set { _objectAlias = value;}
		}

		/// <summary>
		/// The aggregate function to apply on this field in a select query. Ignored in INSERT/UPDATE/DELETE queries. 
		/// Designed to be used in TypedList/TypedView classes.
		/// </summary>
		public AggregateFunction AggregateFunctionToApply 
		{
			get { return _aggregateFunctionToApply;}
			set { _aggregateFunctionToApply=value;}
		}

		/// <summary>
		/// The expression to apply to this field in a select list, update statement or predicate. 
		/// Expression is applied before AggregateFunctionToApply.
		/// </summary>
		public IExpression ExpressionToApply 
		{
			get { return _expressionToApply;}
			set { _expressionToApply = value;}
		}


		/// <summary>
		/// If set to true, in the constructor, this field is part of a foreign key. This field is not used in LLBLGen Pro's code, however
		/// can be useful in user code.
		/// </summary>
		public bool IsForeignKey 
		{
			get { return _fieldInfo.IsForeignKey;}
		}

		/// <summary>
		/// Gets the type converter to use. Only set through constructor and when a conversion is required from the .NET type returned by the 
		/// ADO.NET provider and the defined .NET type for this field.
		/// </summary>
		[XmlIgnore]
		public TypeConverter TypeConverterToUse 
		{ 
			get { return _fieldPersistenceInfo.TypeConverterToUse;}
		}

		
		/// <summary>
		/// The maximum length of the value of the entityfield (string/binary data). Is ignored for entityfields which hold non-string and non-binary values.
		/// Value initially set for this field is the length of the database column this field is mapped on.
		/// </summary>
		[XmlIgnore]
		public int MaxLength
		{
			get { return _fieldInfo.MaxLength; }
		}

		/// <summary>
		/// The scale of the value for this field. 
		/// Value initially set for this field is the scale of the database column this field is mapped on.
		/// </summary>
		[XmlIgnore]
		public byte Scale
		{
			get { return _fieldInfo.Scale; }
		}

		/// <summary>
		/// The precision of the value for this field.
		/// Value initially set for this field is the precision of the database column this field is mapped on.
		/// </summary>
		[XmlIgnore]
		public byte Precision
		{
			get { return _fieldInfo.Precision; }
		}
		
		/// <summary>
		/// The name of the object this field is currently in. Differs only from ContainingObjectName if the field instance is in a subtype while it is
		/// originally defined in a supertype.
		/// </summary>
		/// <example>EmployeeEntity.Name and a subtype, ClerkEntity, inherits this field. For ClerkEntity.Name ContainingObjectName is still 'EmployeeEntity'
		/// however ActualContainingObjectName is 'ClerkEntity'.</example>
		[XmlIgnore]
		public string ActualContainingObjectName
		{
			get { return _fieldInfo.ActualContainingObjectName; }
		}

		/// <summary>
		/// Flag to signal if the field is in a multi-target entity. Used for alias production during query building in scenario's with inheritance.
		/// </summary>
		[XmlIgnore]
		public bool IsInMultiTargetEntity
		{
			get { return _fieldInfo.IsInMultiTargetEntity; }
		}
		#endregion

	}
}
